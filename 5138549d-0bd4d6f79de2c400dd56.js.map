{"version":3,"file":"5138549d-0bd4d6f79de2c400dd56.js","mappings":"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","sources":["webpack://@react-babylonjs/docs/../react-babylonjs/node_modules/@babylonjs/core/Meshes/mesh.js"],"sourcesContent":["import _assertThisInitialized from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _inherits from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _possibleConstructorReturn from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _getPrototypeOf from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _createClass from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _regeneratorRuntime from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/regenerator/index.js\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { Observable } from \"../Misc/observable.js\";\nimport { Tools, AsyncLoop } from \"../Misc/tools.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"../Misc/coroutine.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { ScenePerformancePriority } from \"../scene.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"./mesh.vertexData.js\";\nimport { Geometry } from \"./geometry.js\";\nimport { AbstractMesh } from \"./abstractMesh.js\";\nimport { SubMesh } from \"./subMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { MeshLODLevel } from \"./meshLODLevel.js\";\n/**\n * @internal\n **/\nexport var _CreationDataStorage = /*#__PURE__*/_createClass(function _CreationDataStorage() {\n  _classCallCheck(this, _CreationDataStorage);\n});\n/**\n * @internal\n **/\nvar _InstanceDataStorage = /*#__PURE__*/_createClass(function _InstanceDataStorage() {\n  _classCallCheck(this, _InstanceDataStorage);\n  this.visibleInstances = {};\n  this.batchCache = new _InstancesBatch();\n  this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();\n  this.instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\n});\n/**\n * @internal\n **/\n\nexport var _InstancesBatch = /*#__PURE__*/_createClass(function _InstancesBatch() {\n  _classCallCheck(this, _InstancesBatch);\n  this.mustReturn = false;\n  this.visibleInstances = new Array();\n  this.renderSelf = new Array();\n  this.hardwareInstancedRendering = new Array();\n});\n/**\n * @internal\n **/\nvar _ThinInstanceDataStorage = /*#__PURE__*/_createClass(function _ThinInstanceDataStorage() {\n  _classCallCheck(this, _ThinInstanceDataStorage);\n  this.instancesCount = 0;\n  this.matrixBuffer = null;\n  this.previousMatrixBuffer = null;\n  this.matrixBufferSize = 32 * 16; // let's start with a maximum of 32 thin instances\n  this.matrixData = null;\n  this.boundingVectors = [];\n  this.worldMatrices = null;\n});\n/**\n * @internal\n **/\nvar _InternalMeshDataInfo = /*#__PURE__*/_createClass(function _InternalMeshDataInfo() {\n  _classCallCheck(this, _InternalMeshDataInfo);\n  this._areNormalsFrozen = false; // Will be used by ribbons mainly\n  // Will be used to save a source mesh reference, If any\n  this._source = null;\n  // Will be used to for fast cloned mesh lookup\n  this.meshMap = null;\n  this._preActivateId = -1;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  this._LODLevels = new Array();\n  /** Alternative definition of LOD level, using screen coverage instead of distance */\n  this._useLODScreenCoverage = false;\n  this._effectiveMaterial = null;\n  this._forcedInstanceCount = 0;\n  this._overrideRenderingFillMode = null;\n});\n/**\n * Class used to represent renderable models\n */\nexport var Mesh = /*#__PURE__*/function (_AbstractMesh) {\n  _inherits(Mesh, _AbstractMesh);\n  var _super = _createSuper(Mesh);\n  /**\n   * @constructor\n   * @param name The value used by scene.getMeshByName() to do a lookup.\n   * @param scene The scene to add this mesh to.\n   * @param parent The parent of this mesh, if it has one\n   * @param source An optional Mesh from which geometry is shared, cloned.\n   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n   *                  When false, achieved by calling a clone(), also passing False.\n   *                  This will make creation of children, recursive.\n   * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\n   */\n  function Mesh(name) {\n    var _this;\n    var scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var doNotCloneChildren = arguments.length > 4 ? arguments[4] : undefined;\n    var clonePhysicsImpostor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    _classCallCheck(this, Mesh);\n    _this = _super.call(this, name, scene);\n    // Internal data\n    _this._internalMeshDataInfo = new _InternalMeshDataInfo();\n    // Members\n    /**\n     * Gets the delay loading state of the mesh (when delay loading is turned on)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/incrementalLoading\n     */\n    _this.delayLoadState = 0;\n    /**\n     * Gets the list of instances created from this mesh\n     * it is not supposed to be modified manually.\n     * Note also that the order of the InstancedMesh wihin the array is not significant and might change.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n     */\n    _this.instances = new Array();\n    // Private\n    /** @internal */\n    _this._creationDataStorage = null;\n    /** @internal */\n    _this._geometry = null;\n    /** @internal */\n    _this._instanceDataStorage = new _InstanceDataStorage();\n    /** @internal */\n    _this._thinInstanceDataStorage = new _ThinInstanceDataStorage();\n    /** @internal */\n    _this._shouldGenerateFlatShading = false;\n    // Use by builder only to know what orientation were the mesh build in.\n    /** @internal */\n    _this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;\n    /**\n     * Use this property to change the original side orientation defined at construction time\n     */\n    _this.overrideMaterialSideOrientation = null;\n    /**\n     * Gets or sets a boolean indicating whether to render ignoring the active camera's max z setting. (false by default)\n     * Note this will reduce performance when set to true.\n     */\n    _this.ignoreCameraMaxZ = false;\n    scene = _this.getScene();\n    _this._onBeforeDraw = function (isInstance, world, effectiveMaterial) {\n      if (isInstance && effectiveMaterial) {\n        if (_this._uniformBuffer) {\n          _this.transferToEffect(world);\n        } else {\n          effectiveMaterial.bindOnlyWorldMatrix(world);\n        }\n      }\n    };\n    if (source) {\n      // Geometry\n      if (source._geometry) {\n        source._geometry.applyToMesh(_assertThisInitialized(_this));\n      }\n      // Deep copy\n      DeepCopier.DeepCopy(source, _assertThisInitialized(_this), [\"name\", \"material\", \"skeleton\", \"instances\", \"parent\", \"uniqueId\", \"source\", \"metadata\", \"morphTargetManager\", \"hasInstances\", \"worldMatrixInstancedBuffer\", \"previousWorldMatrixInstancedBuffer\", \"hasLODLevels\", \"geometry\", \"isBlocked\", \"areNormalsFrozen\", \"facetNb\", \"isFacetDataEnabled\", \"lightSources\", \"useBones\", \"isAnInstance\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\", \"cloneMeshMap\", \"hasBoundingInfo\"], [\"_poseMatrix\"]);\n      // Source mesh\n      _this._internalMeshDataInfo._source = source;\n      if (scene.useClonedMeshMap) {\n        if (!source._internalMeshDataInfo.meshMap) {\n          source._internalMeshDataInfo.meshMap = {};\n        }\n        source._internalMeshDataInfo.meshMap[_this.uniqueId] = _assertThisInitialized(_this);\n      }\n      // Construction Params\n      // Clone parameters allowing mesh to be updated in case of parametric shapes.\n      _this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;\n      _this._creationDataStorage = source._creationDataStorage;\n      // Animation ranges\n      if (source._ranges) {\n        var ranges = source._ranges;\n        for (var _name in ranges) {\n          if (!Object.prototype.hasOwnProperty.call(ranges, _name)) {\n            continue;\n          }\n          if (!ranges[_name]) {\n            continue;\n          }\n          _this.createAnimationRange(_name, ranges[_name].from, ranges[_name].to);\n        }\n      }\n      // Metadata\n      if (source.metadata && source.metadata.clone) {\n        _this.metadata = source.metadata.clone();\n      } else {\n        _this.metadata = source.metadata;\n      }\n      _this._internalMetadata = source._internalMetadata;\n      // Tags\n      if (Tags && Tags.HasTags(source)) {\n        Tags.AddTagsTo(_assertThisInitialized(_this), Tags.GetTags(source, true));\n      }\n      // Enabled. We shouldn't need to check the source's ancestors, as this mesh\n      // will have the same ones.\n      _this.setEnabled(source.isEnabled(false));\n      // Parent\n      _this.parent = source.parent;\n      // Pivot\n      _this.setPivotMatrix(source.getPivotMatrix());\n      _this.id = name + \".\" + source.id;\n      // Material\n      _this.material = source.material;\n      if (!doNotCloneChildren) {\n        // Children\n        var directDescendants = source.getDescendants(true);\n        for (var index = 0; index < directDescendants.length; index++) {\n          var child = directDescendants[index];\n          if (child.clone) {\n            child.clone(name + \".\" + child.name, _assertThisInitialized(_this));\n          }\n        }\n      }\n      // Morphs\n      if (source.morphTargetManager) {\n        _this.morphTargetManager = source.morphTargetManager;\n      }\n      // Physics clone\n      if (scene.getPhysicsEngine) {\n        var physicsEngine = scene.getPhysicsEngine();\n        if (clonePhysicsImpostor && physicsEngine) {\n          if (physicsEngine.getPluginVersion() === 1) {\n            var impostor = physicsEngine.getImpostorForPhysicsObject(source);\n            if (impostor) {\n              _this.physicsImpostor = impostor.clone(_assertThisInitialized(_this));\n            }\n          } else if (physicsEngine.getPluginVersion() === 2) {\n            if (source.physicsBody) {\n              source.physicsBody.clone(_assertThisInitialized(_this));\n            }\n          }\n        }\n      }\n      // Particles\n      for (var _index = 0; _index < scene.particleSystems.length; _index++) {\n        var system = scene.particleSystems[_index];\n        if (system.emitter === source) {\n          system.clone(system.name, _assertThisInitialized(_this));\n        }\n      }\n      // Skeleton\n      _this.skeleton = source.skeleton;\n      _this.refreshBoundingInfo(true, true);\n      _this.computeWorldMatrix(true);\n    }\n    // Parent\n    if (parent !== null) {\n      _this.parent = parent;\n    }\n    _this._instanceDataStorage.hardwareInstancedRendering = _this.getEngine().getCaps().instancedArrays;\n    _this._internalMeshDataInfo._onMeshReadyObserverAdded = function (observer) {\n      // only notify once! then unregister the observer\n      observer.unregisterOnNextCall = true;\n      if (_this.isReady(true)) {\n        _this.onMeshReadyObservable.notifyObservers(_assertThisInitialized(_this));\n      } else {\n        if (!_this._internalMeshDataInfo._checkReadinessObserver) {\n          _this._internalMeshDataInfo._checkReadinessObserver = _this._scene.onBeforeRenderObservable.add(function () {\n            // check for complete readiness\n            if (_this.isReady(true)) {\n              _this._scene.onBeforeRenderObservable.remove(_this._internalMeshDataInfo._checkReadinessObserver);\n              _this._internalMeshDataInfo._checkReadinessObserver = null;\n              _this.onMeshReadyObservable.notifyObservers(_assertThisInitialized(_this));\n            }\n          });\n        }\n      }\n    };\n    _this.onMeshReadyObservable = new Observable(_this._internalMeshDataInfo._onMeshReadyObserverAdded);\n    if (source) {\n      source.onClonedObservable.notifyObservers(_assertThisInitialized(_this));\n    }\n    return _this;\n  }\n  _createClass(Mesh, [{\n    key: \"useLODScreenCoverage\",\n    get:\n    /**\n     * Determines if the LOD levels are intended to be calculated using screen coverage (surface area ratio) instead of distance.\n     */\n    function get() {\n      return this._internalMeshDataInfo._useLODScreenCoverage;\n    },\n    set: function set(value) {\n      this._internalMeshDataInfo._useLODScreenCoverage = value;\n      this._sortLODLevels();\n    }\n  }, {\n    key: \"computeBonesUsingShaders\",\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n        return;\n      }\n      if (value && this._internalMeshDataInfo._sourcePositions) {\n        // switch from software to GPU computation: we need to reset the vertex and normal buffers that have been updated by the software process\n        this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);\n        if (this._internalMeshDataInfo._sourceNormals) {\n          this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);\n        }\n        this._internalMeshDataInfo._sourcePositions = null;\n        this._internalMeshDataInfo._sourceNormals = null;\n      }\n      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n      this._markSubMeshesAsAttributesDirty();\n    }\n    /**\n     * An event triggered before rendering the mesh\n     */\n  }, {\n    key: \"onBeforeRenderObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onBeforeRenderObservable) {\n        this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();\n      }\n      return this._internalMeshDataInfo._onBeforeRenderObservable;\n    }\n    /**\n     * An event triggered before binding the mesh\n     */\n  }, {\n    key: \"onBeforeBindObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onBeforeBindObservable) {\n        this._internalMeshDataInfo._onBeforeBindObservable = new Observable();\n      }\n      return this._internalMeshDataInfo._onBeforeBindObservable;\n    }\n    /**\n     * An event triggered after rendering the mesh\n     */\n  }, {\n    key: \"onAfterRenderObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onAfterRenderObservable) {\n        this._internalMeshDataInfo._onAfterRenderObservable = new Observable();\n      }\n      return this._internalMeshDataInfo._onAfterRenderObservable;\n    }\n    /**\n     * An event triggeredbetween rendering pass when using separateCullingPass = true\n     */\n  }, {\n    key: \"onBetweenPassObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onBetweenPassObservable) {\n        this._internalMeshDataInfo._onBetweenPassObservable = new Observable();\n      }\n      return this._internalMeshDataInfo._onBetweenPassObservable;\n    }\n    /**\n     * An event triggered before drawing the mesh\n     */\n  }, {\n    key: \"onBeforeDrawObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onBeforeDrawObservable) {\n        this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();\n      }\n      return this._internalMeshDataInfo._onBeforeDrawObservable;\n    }\n    /**\n     * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead\n     */\n  }, {\n    key: \"onBeforeDraw\",\n    set: function set(callback) {\n      if (this._onBeforeDrawObserver) {\n        this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\n      }\n      this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\n    }\n  }, {\n    key: \"hasInstances\",\n    get: function get() {\n      return this.instances.length > 0;\n    }\n  }, {\n    key: \"hasThinInstances\",\n    get: function get() {\n      var _a;\n      return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;\n    }\n    /**\n     * Gets or sets the forced number of instances to display.\n     * If 0 (default value), the number of instances is not forced and depends on the draw type\n     * (regular / instance / thin instances mesh)\n     */\n  }, {\n    key: \"forcedInstanceCount\",\n    get: function get() {\n      return this._internalMeshDataInfo._forcedInstanceCount;\n    },\n    set: function set(count) {\n      this._internalMeshDataInfo._forcedInstanceCount = count;\n    }\n    /**\n     * Use this property to override the Material's fillMode value\n     */\n  }, {\n    key: \"overrideRenderingFillMode\",\n    get: function get() {\n      return this._internalMeshDataInfo._overrideRenderingFillMode;\n    },\n    set: function set(fillMode) {\n      this._internalMeshDataInfo._overrideRenderingFillMode = fillMode;\n    }\n    /**\n     * Gets the source mesh (the one used to clone this one from)\n     */\n  }, {\n    key: \"source\",\n    get: function get() {\n      return this._internalMeshDataInfo._source;\n    }\n    /**\n     * Gets the list of clones of this mesh\n     * The scene must have been constructed with useClonedMeshMap=true for this to work!\n     * Note that useClonedMeshMap=true is the default setting\n     */\n  }, {\n    key: \"cloneMeshMap\",\n    get: function get() {\n      return this._internalMeshDataInfo.meshMap;\n    }\n    /**\n     * Gets or sets a boolean indicating that this mesh does not use index buffer\n     */\n  }, {\n    key: \"isUnIndexed\",\n    get: function get() {\n      return this._unIndexed;\n    },\n    set: function set(value) {\n      if (this._unIndexed !== value) {\n        this._unIndexed = value;\n        this._markSubMeshesAsAttributesDirty();\n      }\n    }\n    /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */\n  }, {\n    key: \"worldMatrixInstancedBuffer\",\n    get: function get() {\n      return this._instanceDataStorage.instancesData;\n    }\n    /** Gets the array buffer used to store the instanced buffer used for instances' previous world matrices */\n  }, {\n    key: \"previousWorldMatrixInstancedBuffer\",\n    get: function get() {\n      return this._instanceDataStorage.instancesPreviousData;\n    }\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n  }, {\n    key: \"manualUpdateOfWorldMatrixInstancedBuffer\",\n    get: function get() {\n      return this._instanceDataStorage.manualUpdate;\n    },\n    set: function set(value) {\n      this._instanceDataStorage.manualUpdate = value;\n    }\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n  }, {\n    key: \"manualUpdateOfPreviousWorldMatrixInstancedBuffer\",\n    get: function get() {\n      return this._instanceDataStorage.previousManualUpdate;\n    },\n    set: function set(value) {\n      this._instanceDataStorage.previousManualUpdate = value;\n    }\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices must be performed in all cases (and notably even in frozen mode) */\n  }, {\n    key: \"forceWorldMatrixInstancedBufferUpdate\",\n    get: function get() {\n      return this._instanceDataStorage.forceMatrixUpdates;\n    },\n    set: function set(value) {\n      this._instanceDataStorage.forceMatrixUpdates = value;\n    }\n  }, {\n    key: \"instantiateHierarchy\",\n    value: function instantiateHierarchy() {\n      var newParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      var onNewNodeCreated = arguments.length > 2 ? arguments[2] : undefined;\n      var instance = this.getTotalVertices() === 0 || options && options.doNotInstantiate && (options.doNotInstantiate === true || options.doNotInstantiate(this)) ? this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true) : this.createInstance(\"instance of \" + (this.name || this.id));\n      instance.parent = newParent || this.parent;\n      instance.position = this.position.clone();\n      instance.scaling = this.scaling.clone();\n      if (this.rotationQuaternion) {\n        instance.rotationQuaternion = this.rotationQuaternion.clone();\n      } else {\n        instance.rotation = this.rotation.clone();\n      }\n      if (onNewNodeCreated) {\n        onNewNodeCreated(this, instance);\n      }\n      var _iterator = _createForOfIteratorHelper(this.getChildTransformNodes(true)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          // instancedMesh should have a different sourced mesh\n          if (child.getClassName() === \"InstancedMesh\" && instance.getClassName() === \"Mesh\" && child.sourceMesh === this) {\n            child.instantiateHierarchy(instance, {\n              doNotInstantiate: options && options.doNotInstantiate || false,\n              newSourcedMesh: instance\n            }, onNewNodeCreated);\n          } else {\n            child.instantiateHierarchy(instance, options, onNewNodeCreated);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return instance;\n    }\n    /**\n     * Gets the class name\n     * @returns the string \"Mesh\".\n     */\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      return \"Mesh\";\n    }\n    /** @internal */\n  }, {\n    key: \"_isMesh\",\n    get: function get() {\n      return true;\n    }\n    /**\n     * Returns a description of this mesh\n     * @param fullDetails define if full details about this mesh must be used\n     * @returns a descriptive string representing this mesh\n     */\n  }, {\n    key: \"toString\",\n    value: function toString(fullDetails) {\n      var ret = _get(_getPrototypeOf(Mesh.prototype), \"toString\", this).call(this, fullDetails);\n      ret += \", n vertices: \" + this.getTotalVertices();\n      ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : \"NONE\");\n      if (this.animations) {\n        for (var i = 0; i < this.animations.length; i++) {\n          ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n        }\n      }\n      if (fullDetails) {\n        if (this._geometry) {\n          var ib = this.getIndices();\n          var vb = this.getVerticesData(VertexBuffer.PositionKind);\n          if (vb && ib) {\n            ret += \", flat shading: \" + (vb.length / 3 === ib.length ? \"YES\" : \"NO\");\n          }\n        } else {\n          ret += \", flat shading: UNKNOWN\";\n        }\n      }\n      return ret;\n    }\n    /** @internal */\n  }, {\n    key: \"_unBindEffect\",\n    value: function _unBindEffect() {\n      _get(_getPrototypeOf(Mesh.prototype), \"_unBindEffect\", this).call(this);\n      var _iterator2 = _createForOfIteratorHelper(this.instances),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var instance = _step2.value;\n          instance._unBindEffect();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Gets a boolean indicating if this mesh has LOD\n     */\n  }, {\n    key: \"hasLODLevels\",\n    get: function get() {\n      return this._internalMeshDataInfo._LODLevels.length > 0;\n    }\n    /**\n     * Gets the list of MeshLODLevel associated with the current mesh\n     * @returns an array of MeshLODLevel\n     */\n  }, {\n    key: \"getLODLevels\",\n    value: function getLODLevels() {\n      return this._internalMeshDataInfo._LODLevels;\n    }\n  }, {\n    key: \"_sortLODLevels\",\n    value: function _sortLODLevels() {\n      var sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;\n      this._internalMeshDataInfo._LODLevels.sort(function (a, b) {\n        if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {\n          return sortingOrderFactor;\n        }\n        if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {\n          return -sortingOrderFactor;\n        }\n        return 0;\n      });\n    }\n    /**\n     * Add a mesh as LOD level triggered at the given distance.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n     * @param distanceOrScreenCoverage Either distance from the center of the object to show this level or the screen coverage if `useScreenCoverage` is set to `true`.\n     * If screen coverage, value is a fraction of the screen's total surface, between 0 and 1.\n     * Example Playground for distance https://playground.babylonjs.com/#QE7KM#197\n     * Example Playground for screen coverage https://playground.babylonjs.com/#QE7KM#196\n     * @param mesh The mesh to be added as LOD level (can be null)\n     * @returns This mesh (for chaining)\n     */\n  }, {\n    key: \"addLODLevel\",\n    value: function addLODLevel(distanceOrScreenCoverage, mesh) {\n      if (mesh && mesh._masterMesh) {\n        Logger.Warn(\"You cannot use a mesh as LOD level twice\");\n        return this;\n      }\n      var level = new MeshLODLevel(distanceOrScreenCoverage, mesh);\n      this._internalMeshDataInfo._LODLevels.push(level);\n      if (mesh) {\n        mesh._masterMesh = this;\n      }\n      this._sortLODLevels();\n      return this;\n    }\n    /**\n     * Returns the LOD level mesh at the passed distance or null if not found.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n     * @param distance The distance from the center of the object to show this level\n     * @returns a Mesh or `null`\n     */\n  }, {\n    key: \"getLODLevelAtDistance\",\n    value: function getLODLevelAtDistance(distance) {\n      var internalDataInfo = this._internalMeshDataInfo;\n      for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n        var level = internalDataInfo._LODLevels[index];\n        if (level.distanceOrScreenCoverage === distance) {\n          return level.mesh;\n        }\n      }\n      return null;\n    }\n    /**\n     * Remove a mesh from the LOD array\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n     * @param mesh defines the mesh to be removed\n     * @returns This mesh (for chaining)\n     */\n  }, {\n    key: \"removeLODLevel\",\n    value: function removeLODLevel(mesh) {\n      var internalDataInfo = this._internalMeshDataInfo;\n      for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n        if (internalDataInfo._LODLevels[index].mesh === mesh) {\n          internalDataInfo._LODLevels.splice(index, 1);\n          if (mesh) {\n            mesh._masterMesh = null;\n          }\n        }\n      }\n      this._sortLODLevels();\n      return this;\n    }\n    /**\n     * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n     * @param camera defines the camera to use to compute distance\n     * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh\n     * @returns This mesh (for chaining)\n     */\n  }, {\n    key: \"getLOD\",\n    value: function getLOD(camera, boundingSphere) {\n      var internalDataInfo = this._internalMeshDataInfo;\n      if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {\n        return this;\n      }\n      var bSphere = boundingSphere || this.getBoundingInfo().boundingSphere;\n      var distanceToCamera = camera.mode === Camera.ORTHOGRAPHIC_CAMERA ? camera.minZ : bSphere.centerWorld.subtract(camera.globalPosition).length();\n      var compareValue = distanceToCamera;\n      var compareSign = 1;\n      if (internalDataInfo._useLODScreenCoverage) {\n        var screenArea = camera.screenArea;\n        var meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;\n        meshArea = meshArea * meshArea * Math.PI;\n        compareValue = meshArea / screenArea;\n        compareSign = -1;\n      }\n      if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {\n        if (this.onLODLevelSelection) {\n          this.onLODLevelSelection(compareValue, this, this);\n        }\n        return this;\n      }\n      for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n        var level = internalDataInfo._LODLevels[index];\n        if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {\n          if (level.mesh) {\n            if (level.mesh.delayLoadState === 4) {\n              level.mesh._checkDelayState();\n              return this;\n            }\n            if (level.mesh.delayLoadState === 2) {\n              return this;\n            }\n            level.mesh._preActivate();\n            level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n          }\n          if (this.onLODLevelSelection) {\n            this.onLODLevelSelection(compareValue, this, level.mesh);\n          }\n          return level.mesh;\n        }\n      }\n      if (this.onLODLevelSelection) {\n        this.onLODLevelSelection(compareValue, this, this);\n      }\n      return this;\n    }\n    /**\n     * Gets the mesh internal Geometry object\n     */\n  }, {\n    key: \"geometry\",\n    get: function get() {\n      return this._geometry;\n    }\n    /**\n     * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\n     * @returns the total number of vertices\n     */\n  }, {\n    key: \"getTotalVertices\",\n    value: function getTotalVertices() {\n      if (this._geometry === null || this._geometry === undefined) {\n        return 0;\n      }\n      return this._geometry.getTotalVertices();\n    }\n    /**\n     * Returns the content of an associated vertex buffer\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.\n     */\n  }, {\n    key: \"getVerticesData\",\n    value: function getVerticesData(kind, copyWhenShared, forceCopy, bypassInstanceData) {\n      var _a, _b;\n      if (!this._geometry) {\n        return null;\n      }\n      var data = bypassInstanceData ? undefined : (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(this.instances.length + 1,\n      // +1 because the master mesh is not included in the instances array\n      forceCopy || copyWhenShared && this._geometry.meshes.length !== 1);\n      if (!data) {\n        data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\n      }\n      return data;\n    }\n    /**\n     * Returns the mesh VertexBuffer object from the requested `kind`\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.NormalKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\n     */\n  }, {\n    key: \"getVertexBuffer\",\n    value: function getVertexBuffer(kind, bypassInstanceData) {\n      var _a, _b;\n      if (!this._geometry) {\n        return null;\n      }\n      return (_b = bypassInstanceData ? undefined : (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);\n    }\n    /**\n     * Tests if a specific vertex buffer is associated with this mesh\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.NormalKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns a boolean\n     */\n  }, {\n    key: \"isVerticesDataPresent\",\n    value: function isVerticesDataPresent(kind, bypassInstanceData) {\n      var _a;\n      if (!this._geometry) {\n        if (this._delayInfo) {\n          return this._delayInfo.indexOf(kind) !== -1;\n        }\n        return false;\n      }\n      return !bypassInstanceData && ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== undefined || this._geometry.isVerticesDataPresent(kind);\n    }\n    /**\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable.\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns a boolean\n     */\n  }, {\n    key: \"isVertexBufferUpdatable\",\n    value: function isVertexBufferUpdatable(kind, bypassInstanceData) {\n      var _a;\n      if (!this._geometry) {\n        if (this._delayInfo) {\n          return this._delayInfo.indexOf(kind) !== -1;\n        }\n        return false;\n      }\n      if (!bypassInstanceData) {\n        var buffer = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind];\n        if (buffer) {\n          return buffer.isUpdatable();\n        }\n      }\n      return this._geometry.isVertexBufferUpdatable(kind);\n    }\n    /**\n     * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.\n     * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n     * @returns an array of strings\n     */\n  }, {\n    key: \"getVerticesDataKinds\",\n    value: function getVerticesDataKinds(bypassInstanceData) {\n      if (!this._geometry) {\n        var result = new Array();\n        if (this._delayInfo) {\n          this._delayInfo.forEach(function (kind) {\n            result.push(kind);\n          });\n        }\n        return result;\n      }\n      var kinds = this._geometry.getVerticesDataKinds();\n      if (!bypassInstanceData && this._userInstancedBuffersStorage) {\n        for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {\n          if (kinds.indexOf(kind) === -1) {\n            kinds.push(kind);\n          }\n        }\n      }\n      return kinds;\n    }\n    /**\n     * Returns a positive integer : the total number of indices in this mesh geometry.\n     * @returns the numner of indices or zero if the mesh has no geometry.\n     */\n  }, {\n    key: \"getTotalIndices\",\n    value: function getTotalIndices() {\n      if (!this._geometry) {\n        return 0;\n      }\n      return this._geometry.getTotalIndices();\n    }\n    /**\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n     * @returns the indices array or an empty array if the mesh has no geometry\n     */\n  }, {\n    key: \"getIndices\",\n    value: function getIndices(copyWhenShared, forceCopy) {\n      if (!this._geometry) {\n        return [];\n      }\n      return this._geometry.getIndices(copyWhenShared, forceCopy);\n    }\n  }, {\n    key: \"isBlocked\",\n    get: function get() {\n      return this._masterMesh !== null && this._masterMesh !== undefined;\n    }\n    /**\n     * Determine if the current mesh is ready to be rendered\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n     * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)\n     * @returns true if all associated assets are ready (material, textures, shaders)\n     */\n  }, {\n    key: \"isReady\",\n    value: function isReady() {\n      var completeCheck = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var forceInstanceSupport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _a, _b, _c, _d, _e, _f;\n      if (this.delayLoadState === 2) {\n        return false;\n      }\n      if (!_get(_getPrototypeOf(Mesh.prototype), \"isReady\", this).call(this, completeCheck)) {\n        return false;\n      }\n      if (!this.subMeshes || this.subMeshes.length === 0) {\n        return true;\n      }\n      if (!completeCheck) {\n        return true;\n      }\n      var engine = this.getEngine();\n      var scene = this.getScene();\n      var hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);\n      this.computeWorldMatrix();\n      var mat = this.material || scene.defaultMaterial;\n      if (mat) {\n        if (mat._storeEffectOnSubMeshes) {\n          var _iterator3 = _createForOfIteratorHelper(this.subMeshes),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var subMesh = _step3.value;\n              var effectiveMaterial = subMesh.getMaterial();\n              if (effectiveMaterial) {\n                if (effectiveMaterial._storeEffectOnSubMeshes) {\n                  if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                    return false;\n                  }\n                } else {\n                  if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\n                    return false;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else {\n          if (!mat.isReady(this, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n      // Shadows\n      var currentRenderPassId = engine.currentRenderPassId;\n      var _iterator4 = _createForOfIteratorHelper(this.lightSources),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var light = _step4.value;\n          var generators = light.getShadowGenerators();\n          if (!generators) {\n            continue;\n          }\n          var iterator = generators.values();\n          for (var key = iterator.next(); key.done !== true; key = iterator.next()) {\n            var generator = key.value;\n            if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {\n              if (generator.getShadowMap()) {\n                engine.currentRenderPassId = generator.getShadowMap().renderPassId;\n              }\n              var _iterator6 = _createForOfIteratorHelper(this.subMeshes),\n                _step6;\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var _subMesh = _step6.value;\n                  if (!generator.isReady(_subMesh, hardwareInstancedRendering, (_f = (_e = _subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {\n                    engine.currentRenderPassId = currentRenderPassId;\n                    return false;\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n              engine.currentRenderPassId = currentRenderPassId;\n            }\n          }\n        }\n        // LOD\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var _iterator5 = _createForOfIteratorHelper(this._internalMeshDataInfo._LODLevels),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var lod = _step5.value;\n          if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return true;\n    }\n    /**\n     * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.\n     */\n  }, {\n    key: \"areNormalsFrozen\",\n    get: function get() {\n      return this._internalMeshDataInfo._areNormalsFrozen;\n    }\n    /**\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.\n     * @returns the current mesh\n     */\n  }, {\n    key: \"freezeNormals\",\n    value: function freezeNormals() {\n      this._internalMeshDataInfo._areNormalsFrozen = true;\n      return this;\n    }\n    /**\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen\n     * @returns the current mesh\n     */\n  }, {\n    key: \"unfreezeNormals\",\n    value: function unfreezeNormals() {\n      this._internalMeshDataInfo._areNormalsFrozen = false;\n      return this;\n    }\n    /**\n     * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\n     */\n  }, {\n    key: \"overridenInstanceCount\",\n    set: function set(count) {\n      this._instanceDataStorage.overridenInstanceCount = count;\n    }\n    // Methods\n    /** @internal */\n  }, {\n    key: \"_preActivate\",\n    value: function _preActivate() {\n      var internalDataInfo = this._internalMeshDataInfo;\n      var sceneRenderId = this.getScene().getRenderId();\n      if (internalDataInfo._preActivateId === sceneRenderId) {\n        return this;\n      }\n      internalDataInfo._preActivateId = sceneRenderId;\n      this._instanceDataStorage.visibleInstances = null;\n      return this;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_preActivateForIntermediateRendering\",\n    value: function _preActivateForIntermediateRendering(renderId) {\n      if (this._instanceDataStorage.visibleInstances) {\n        this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;\n      }\n      return this;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_registerInstanceForRenderId\",\n    value: function _registerInstanceForRenderId(instance, renderId) {\n      if (!this._instanceDataStorage.visibleInstances) {\n        this._instanceDataStorage.visibleInstances = {\n          defaultRenderId: renderId,\n          selfDefaultRenderId: this._renderId\n        };\n      }\n      if (!this._instanceDataStorage.visibleInstances[renderId]) {\n        if (this._instanceDataStorage.previousRenderId !== undefined && this._instanceDataStorage.isFrozen) {\n          this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;\n        }\n        this._instanceDataStorage.previousRenderId = renderId;\n        this._instanceDataStorage.visibleInstances[renderId] = new Array();\n      }\n      this._instanceDataStorage.visibleInstances[renderId].push(instance);\n      return this;\n    }\n  }, {\n    key: \"_afterComputeWorldMatrix\",\n    value: function _afterComputeWorldMatrix() {\n      _get(_getPrototypeOf(Mesh.prototype), \"_afterComputeWorldMatrix\", this).call(this);\n      if (!this.hasThinInstances) {\n        return;\n      }\n      if (!this.doNotSyncBoundingInfo) {\n        this.thinInstanceRefreshBoundingInfo(false);\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_postActivate\",\n    value: function _postActivate() {\n      if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {\n        this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);\n        this.edgesRenderer.customInstances.push(this.getWorldMatrix());\n      }\n    }\n    /**\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n     * This means the mesh underlying bounding box and sphere are recomputed.\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n     * @returns the current mesh\n     */\n  }, {\n    key: \"refreshBoundingInfo\",\n    value: function refreshBoundingInfo() {\n      var applySkeleton = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var applyMorph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n        return this;\n      }\n      var bias = this.geometry ? this.geometry.boundingBias : null;\n      this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);\n      return this;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_createGlobalSubMesh\",\n    value: function _createGlobalSubMesh(force) {\n      var totalVertices = this.getTotalVertices();\n      if (!totalVertices || !this.getIndices()) {\n        return null;\n      }\n      // Check if we need to recreate the submeshes\n      if (this.subMeshes && this.subMeshes.length > 0) {\n        var ib = this.getIndices();\n        if (!ib) {\n          return null;\n        }\n        var totalIndices = ib.length;\n        var needToRecreate = false;\n        if (force) {\n          needToRecreate = true;\n        } else {\n          var _iterator7 = _createForOfIteratorHelper(this.subMeshes),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var submesh = _step7.value;\n              if (submesh.indexStart + submesh.indexCount > totalIndices) {\n                needToRecreate = true;\n                break;\n              }\n              if (submesh.verticesStart + submesh.verticesCount > totalVertices) {\n                needToRecreate = true;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n        if (!needToRecreate) {\n          return this.subMeshes[0];\n        }\n      }\n      this.releaseSubMeshes();\n      return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\n    }\n    /**\n     * This function will subdivide the mesh into multiple submeshes\n     * @param count defines the expected number of submeshes\n     */\n  }, {\n    key: \"subdivide\",\n    value: function subdivide(count) {\n      if (count < 1) {\n        return;\n      }\n      var totalIndices = this.getTotalIndices();\n      var subdivisionSize = totalIndices / count | 0;\n      var offset = 0;\n      // Ensure that subdivisionSize is a multiple of 3\n      while (subdivisionSize % 3 !== 0) {\n        subdivisionSize++;\n      }\n      this.releaseSubMeshes();\n      for (var index = 0; index < count; index++) {\n        if (offset >= totalIndices) {\n          break;\n        }\n        SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);\n        offset += subdivisionSize;\n      }\n      this.synchronizeInstances();\n    }\n    /**\n     * Copy a FloatArray into a specific associated vertex buffer\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\n     * @param stride defines the data stride size (can be null)\n     * @returns the current mesh\n     */\n  }, {\n    key: \"setVerticesData\",\n    value: function setVerticesData(kind, data) {\n      var updatable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var stride = arguments.length > 3 ? arguments[3] : undefined;\n      if (!this._geometry) {\n        var vertexData = new VertexData();\n        vertexData.set(data, kind);\n        var scene = this.getScene();\n        new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n      } else {\n        this._geometry.setVerticesData(kind, data, updatable, stride);\n      }\n      return this;\n    }\n    /**\n     * Delete a vertex buffer associated with this mesh\n     * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     */\n  }, {\n    key: \"removeVerticesData\",\n    value: function removeVerticesData(kind) {\n      if (!this._geometry) {\n        return;\n      }\n      this._geometry.removeVerticesData(kind);\n    }\n    /**\n     * Flags an associated vertex buffer as updatable\n     * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\n     */\n  }, {\n    key: \"markVerticesDataAsUpdatable\",\n    value: function markVerticesDataAsUpdatable(kind) {\n      var updatable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var vb = this.getVertexBuffer(kind);\n      if (!vb || vb.isUpdatable() === updatable) {\n        return;\n      }\n      this.setVerticesData(kind, this.getVerticesData(kind), updatable);\n    }\n    /**\n     * Sets the mesh global Vertex Buffer\n     * @param buffer defines the buffer to use\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n     * @returns the current mesh\n     */\n  }, {\n    key: \"setVerticesBuffer\",\n    value: function setVerticesBuffer(buffer) {\n      var disposeExistingBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!this._geometry) {\n        this._geometry = Geometry.CreateGeometryForMesh(this);\n      }\n      this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);\n      return this;\n    }\n    /**\n     * Update a specific associated vertex buffer\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\n     * @returns the current mesh\n     */\n  }, {\n    key: \"updateVerticesData\",\n    value: function updateVerticesData(kind, data, updateExtends, makeItUnique) {\n      if (!this._geometry) {\n        return this;\n      }\n      if (!makeItUnique) {\n        this._geometry.updateVerticesData(kind, data, updateExtends);\n      } else {\n        this.makeGeometryUnique();\n        this.updateVerticesData(kind, data, updateExtends, false);\n      }\n      return this;\n    }\n    /**\n     * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#other-shapes-updatemeshpositions\n     * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything\n     * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update\n     * @returns the current mesh\n     */\n  }, {\n    key: \"updateMeshPositions\",\n    value: function updateMeshPositions(positionFunction) {\n      var computeNormals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var positions = this.getVerticesData(VertexBuffer.PositionKind);\n      if (!positions) {\n        return this;\n      }\n      positionFunction(positions);\n      this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n      if (computeNormals) {\n        var indices = this.getIndices();\n        var normals = this.getVerticesData(VertexBuffer.NormalKind);\n        if (!normals) {\n          return this;\n        }\n        VertexData.ComputeNormals(positions, indices, normals);\n        this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n      }\n      return this;\n    }\n    /**\n     * Creates a un-shared specific occurence of the geometry for the mesh.\n     * @returns the current mesh\n     */\n  }, {\n    key: \"makeGeometryUnique\",\n    value: function makeGeometryUnique() {\n      if (!this._geometry) {\n        return this;\n      }\n      if (this._geometry.meshes.length === 1) {\n        return this;\n      }\n      var oldGeometry = this._geometry;\n      var geometry = this._geometry.copy(Geometry.RandomId());\n      oldGeometry.releaseForMesh(this, true);\n      geometry.applyToMesh(this);\n      return this;\n    }\n    /**\n     * Set the index buffer of this mesh\n     * @param indices defines the source data\n     * @param totalVertices defines the total number of vertices referenced by this index data (can be null)\n     * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)\n     * @returns the current mesh\n     */\n  }, {\n    key: \"setIndices\",\n    value: function setIndices(indices) {\n      var totalVertices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var updatable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (!this._geometry) {\n        var vertexData = new VertexData();\n        vertexData.indices = indices;\n        var scene = this.getScene();\n        new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n      } else {\n        this._geometry.setIndices(indices, totalVertices, updatable);\n      }\n      return this;\n    }\n    /**\n     * Update the current index buffer\n     * @param indices defines the source data\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n     * @returns the current mesh\n     */\n  }, {\n    key: \"updateIndices\",\n    value: function updateIndices(indices, offset) {\n      var gpuMemoryOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (!this._geometry) {\n        return this;\n      }\n      this._geometry.updateIndices(indices, offset, gpuMemoryOnly);\n      return this;\n    }\n    /**\n     * Invert the geometry to move from a right handed system to a left handed one.\n     * @returns the current mesh\n     */\n  }, {\n    key: \"toLeftHanded\",\n    value: function toLeftHanded() {\n      if (!this._geometry) {\n        return this;\n      }\n      this._geometry.toLeftHanded();\n      return this;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_bind\",\n    value: function _bind(subMesh, effect, fillMode) {\n      var allowInstancedRendering = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      if (!this._geometry) {\n        return this;\n      }\n      var engine = this.getScene().getEngine();\n      // Morph targets\n      if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {\n        this.morphTargetManager._bind(effect);\n      }\n      // Wireframe\n      var indexToBind;\n      if (this._unIndexed) {\n        indexToBind = null;\n      } else {\n        switch (this._getRenderingFillMode(fillMode)) {\n          case Material.PointFillMode:\n            indexToBind = null;\n            break;\n          case Material.WireFrameFillMode:\n            indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);\n            break;\n          default:\n          case Material.TriangleFillMode:\n            indexToBind = this._geometry.getIndexBuffer();\n            break;\n        }\n      }\n      // VBOs\n      if (!allowInstancedRendering || !this._userInstancedBuffersStorage || this.hasThinInstances) {\n        this._geometry._bind(effect, indexToBind);\n      } else {\n        this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n      }\n      return this;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_draw\",\n    value: function _draw(subMesh, fillMode, instancesCount) {\n      if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n        return this;\n      }\n      if (this._internalMeshDataInfo._onBeforeDrawObservable) {\n        this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);\n      }\n      var scene = this.getScene();\n      var engine = scene.getEngine();\n      if (this._unIndexed || fillMode == Material.PointFillMode) {\n        // or triangles as points\n        engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);\n      } else if (fillMode == Material.WireFrameFillMode) {\n        // Triangles as wireframe\n        engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);\n      } else {\n        engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);\n      }\n      return this;\n    }\n    /**\n     * Registers for this mesh a javascript function called just before the rendering process\n     * @param func defines the function to call before rendering this mesh\n     * @returns the current mesh\n     */\n  }, {\n    key: \"registerBeforeRender\",\n    value: function registerBeforeRender(func) {\n      this.onBeforeRenderObservable.add(func);\n      return this;\n    }\n    /**\n     * Disposes a previously registered javascript function called before the rendering\n     * @param func defines the function to remove\n     * @returns the current mesh\n     */\n  }, {\n    key: \"unregisterBeforeRender\",\n    value: function unregisterBeforeRender(func) {\n      this.onBeforeRenderObservable.removeCallback(func);\n      return this;\n    }\n    /**\n     * Registers for this mesh a javascript function called just after the rendering is complete\n     * @param func defines the function to call after rendering this mesh\n     * @returns the current mesh\n     */\n  }, {\n    key: \"registerAfterRender\",\n    value: function registerAfterRender(func) {\n      this.onAfterRenderObservable.add(func);\n      return this;\n    }\n    /**\n     * Disposes a previously registered javascript function called after the rendering.\n     * @param func defines the function to remove\n     * @returns the current mesh\n     */\n  }, {\n    key: \"unregisterAfterRender\",\n    value: function unregisterAfterRender(func) {\n      this.onAfterRenderObservable.removeCallback(func);\n      return this;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_getInstancesRenderList\",\n    value: function _getInstancesRenderList(subMeshId) {\n      var isReplacementMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this._instanceDataStorage.isFrozen) {\n        if (isReplacementMode) {\n          this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;\n          this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;\n          return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;\n        }\n        if (this._instanceDataStorage.previousBatch) {\n          return this._instanceDataStorage.previousBatch;\n        }\n      }\n      var scene = this.getScene();\n      var isInIntermediateRendering = scene._isInIntermediateRendering();\n      var onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;\n      var batchCache = this._instanceDataStorage.batchCache;\n      batchCache.mustReturn = false;\n      batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;\n      batchCache.visibleInstances[subMeshId] = null;\n      if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {\n        var visibleInstances = this._instanceDataStorage.visibleInstances;\n        var currentRenderId = scene.getRenderId();\n        var defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;\n        batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];\n        if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {\n          batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];\n        }\n      }\n      batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== undefined;\n      this._instanceDataStorage.previousBatch = batchCache;\n      return batchCache;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_renderWithInstances\",\n    value: function _renderWithInstances(subMesh, fillMode, batch, effect, engine) {\n      var _a;\n      var visibleInstances = batch.visibleInstances[subMesh._id];\n      var visibleInstanceCount = visibleInstances ? visibleInstances.length : 0;\n      var instanceStorage = this._instanceDataStorage;\n      var currentInstancesBufferSize = instanceStorage.instancesBufferSize;\n      var instancesBuffer = instanceStorage.instancesBuffer;\n      var instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;\n      var matricesCount = visibleInstanceCount + 1;\n      var bufferSize = matricesCount * 16 * 4;\n      while (instanceStorage.instancesBufferSize < bufferSize) {\n        instanceStorage.instancesBufferSize *= 2;\n      }\n      if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n        instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n      }\n      if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n        instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n      }\n      var offset = 0;\n      var instancesCount = 0;\n      var renderSelf = batch.renderSelf[subMesh._id];\n      var needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;\n      if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {\n        var world = this.getWorldMatrix();\n        if (renderSelf) {\n          if (this._scene.needsPreviousWorldMatrices) {\n            if (!instanceStorage.masterMeshPreviousWorldMatrix) {\n              instanceStorage.masterMeshPreviousWorldMatrix = world.clone();\n              instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n            } else {\n              instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n              instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);\n            }\n          }\n          world.copyToArray(instanceStorage.instancesData, offset);\n          offset += 16;\n          instancesCount++;\n        }\n        if (visibleInstances) {\n          if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {\n            var cameraPosition = this._scene.activeCamera.globalPosition;\n            for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n              var instanceMesh = visibleInstances[instanceIndex];\n              instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n            }\n            visibleInstances.sort(function (m1, m2) {\n              return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;\n            });\n          }\n          for (var _instanceIndex = 0; _instanceIndex < visibleInstances.length; _instanceIndex++) {\n            var instance = visibleInstances[_instanceIndex];\n            var matrix = instance.getWorldMatrix();\n            matrix.copyToArray(instanceStorage.instancesData, offset);\n            if (this._scene.needsPreviousWorldMatrices) {\n              if (!instance._previousWorldMatrix) {\n                instance._previousWorldMatrix = matrix.clone();\n                instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n              } else {\n                instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                instance._previousWorldMatrix.copyFrom(matrix);\n              }\n            }\n            offset += 16;\n            instancesCount++;\n          }\n        }\n      } else {\n        instancesCount = (renderSelf ? 1 : 0) + visibleInstanceCount;\n      }\n      if (needUpdateBuffer) {\n        if (instancesBuffer) {\n          instancesBuffer.dispose();\n        }\n        if (instancesPreviousBuffer) {\n          instancesPreviousBuffer.dispose();\n        }\n        instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);\n        instanceStorage.instancesBuffer = instancesBuffer;\n        if (!this._userInstancedBuffersStorage) {\n          this._userInstancedBuffersStorage = {\n            data: {},\n            vertexBuffers: {},\n            strides: {},\n            sizes: {},\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined\n          };\n        }\n        this._userInstancedBuffersStorage.vertexBuffers[\"world0\"] = instancesBuffer.createVertexBuffer(\"world0\", 0, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"world1\"] = instancesBuffer.createVertexBuffer(\"world1\", 4, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"world2\"] = instancesBuffer.createVertexBuffer(\"world2\", 8, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"world3\"] = instancesBuffer.createVertexBuffer(\"world3\", 12, 4);\n        if (this._scene.needsPreviousWorldMatrices) {\n          instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);\n          instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;\n          this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld0\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld0\", 0, 4);\n          this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld1\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld1\", 4, 4);\n          this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld2\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld2\", 8, 4);\n          this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld3\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld3\", 12, 4);\n        }\n        this._invalidateInstanceVertexArrayObject();\n      } else {\n        if (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) {\n          instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n          if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {\n            instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);\n          }\n        }\n      }\n      this._processInstancedBuffers(visibleInstances, renderSelf);\n      // Stats\n      this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n      // Draw\n      if (engine._currentDrawContext) {\n        engine._currentDrawContext.useInstancing = true;\n      }\n      this._bind(subMesh, effect, fillMode);\n      this._draw(subMesh, fillMode, instancesCount);\n      // Write current matrices as previous matrices in case of manual update\n      // Default behaviour when previous matrices are not specified explicitly\n      // Will break if instances number/order changes\n      if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && !this._instanceDataStorage.previousManualUpdate) {\n        instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n      }\n      engine.unbindInstanceAttributes();\n      return this;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_renderWithThinInstances\",\n    value: function _renderWithThinInstances(subMesh, fillMode, effect, engine) {\n      var _a, _b;\n      // Stats\n      var instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;\n      this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n      // Draw\n      if (engine._currentDrawContext) {\n        engine._currentDrawContext.useInstancing = true;\n      }\n      this._bind(subMesh, effect, fillMode);\n      this._draw(subMesh, fillMode, instancesCount);\n      // Write current matrices as previous matrices\n      // Default behaviour when previous matrices are not specified explicitly\n      // Will break if instances number/order changes\n      if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {\n        if (!this._thinInstanceDataStorage.previousMatrixBuffer) {\n          this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.matrixData, false);\n        } else {\n          this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);\n        }\n      }\n      engine.unbindInstanceAttributes();\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  }, {\n    key: \"_processInstancedBuffers\",\n    value: function _processInstancedBuffers(visibleInstances, renderSelf) {\n      // Do nothing\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_processRendering\",\n    value: function _processRendering(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {\n      var scene = this.getScene();\n      var engine = scene.getEngine();\n      fillMode = this._getRenderingFillMode(fillMode);\n      if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {\n        this._renderWithThinInstances(subMesh, fillMode, effect, engine);\n        return this;\n      }\n      if (hardwareInstancedRendering) {\n        this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\n      } else {\n        if (engine._currentDrawContext) {\n          engine._currentDrawContext.useInstancing = false;\n        }\n        var instanceCount = 0;\n        if (batch.renderSelf[subMesh._id]) {\n          // Draw\n          if (onBeforeDraw) {\n            onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);\n          }\n          instanceCount++;\n          this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);\n        }\n        var visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];\n        if (visibleInstancesForSubMesh) {\n          var visibleInstanceCount = visibleInstancesForSubMesh.length;\n          instanceCount += visibleInstanceCount;\n          // Stats\n          for (var instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {\n            var instance = visibleInstancesForSubMesh[instanceIndex];\n            // World\n            var world = instance.getWorldMatrix();\n            if (onBeforeDraw) {\n              onBeforeDraw(true, world, effectiveMaterial);\n            }\n            // Draw\n            this._draw(subMesh, fillMode);\n          }\n        }\n        // Stats\n        scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);\n      }\n      return this;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_rebuild\",\n    value: function _rebuild() {\n      var dispose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this._instanceDataStorage.instancesBuffer) {\n        // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n        if (dispose) {\n          this._instanceDataStorage.instancesBuffer.dispose();\n        }\n        this._instanceDataStorage.instancesBuffer = null;\n      }\n      if (this._userInstancedBuffersStorage) {\n        for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {\n          var buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];\n          if (buffer) {\n            // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n            if (dispose) {\n              buffer.dispose();\n            }\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n          }\n        }\n        if (this._userInstancedBuffersStorage.vertexArrayObjects) {\n          this._userInstancedBuffersStorage.vertexArrayObjects = {};\n        }\n      }\n      this._internalMeshDataInfo._effectiveMaterial = null;\n      _get(_getPrototypeOf(Mesh.prototype), \"_rebuild\", this).call(this, dispose);\n    }\n    /** @internal */\n  }, {\n    key: \"_freeze\",\n    value: function _freeze() {\n      if (!this.subMeshes) {\n        return;\n      }\n      // Prepare batches\n      for (var index = 0; index < this.subMeshes.length; index++) {\n        this._getInstancesRenderList(index);\n      }\n      this._internalMeshDataInfo._effectiveMaterial = null;\n      this._instanceDataStorage.isFrozen = true;\n    }\n    /** @internal */\n  }, {\n    key: \"_unFreeze\",\n    value: function _unFreeze() {\n      this._instanceDataStorage.isFrozen = false;\n      this._instanceDataStorage.previousBatch = null;\n    }\n    /**\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n     * @param subMesh defines the subMesh to render\n     * @param enableAlphaMode defines if alpha mode can be changed\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n     * @returns the current mesh\n     */\n  }, {\n    key: \"render\",\n    value: function render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n      var _a, _b, _c;\n      var scene = this.getScene();\n      if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {\n        this._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      } else {\n        this._internalAbstractMeshDataInfo._isActive = false;\n      }\n      if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {\n        return this;\n      }\n      // Managing instances\n      var batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);\n      if (batch.mustReturn) {\n        return this;\n      }\n      // Checking geometry state\n      if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n        return this;\n      }\n      var engine = scene.getEngine();\n      var oldCameraMaxZ = 0;\n      var oldCamera = null;\n      if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {\n        oldCameraMaxZ = scene.activeCamera.maxZ;\n        oldCamera = scene.activeCamera;\n        scene.activeCamera.maxZ = 0;\n        scene.updateTransformMatrix(true);\n      }\n      if (this._internalMeshDataInfo._onBeforeRenderObservable) {\n        this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);\n      }\n      var renderingMesh = subMesh.getRenderingMesh();\n      var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances || !!this._userInstancedBuffersStorage && !subMesh.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh;\n      var instanceDataStorage = this._instanceDataStorage;\n      var material = subMesh.getMaterial();\n      if (!material) {\n        if (oldCamera) {\n          oldCamera.maxZ = oldCameraMaxZ;\n          scene.updateTransformMatrix(true);\n        }\n        return this;\n      }\n      // Material\n      if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {\n        if (material._storeEffectOnSubMeshes) {\n          if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n            if (oldCamera) {\n              oldCamera.maxZ = oldCameraMaxZ;\n              scene.updateTransformMatrix(true);\n            }\n            return this;\n          }\n        } else if (!material.isReady(this, hardwareInstancedRendering)) {\n          if (oldCamera) {\n            oldCamera.maxZ = oldCameraMaxZ;\n            scene.updateTransformMatrix(true);\n          }\n          return this;\n        }\n        this._internalMeshDataInfo._effectiveMaterial = material;\n      } else if (material._storeEffectOnSubMeshes && !((_a = subMesh.effect) === null || _a === void 0 ? void 0 : _a._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_b = material.getEffect()) === null || _b === void 0 ? void 0 : _b._wasPreviouslyReady)) {\n        if (oldCamera) {\n          oldCamera.maxZ = oldCameraMaxZ;\n          scene.updateTransformMatrix(true);\n        }\n        return this;\n      }\n      // Alpha mode\n      if (enableAlphaMode) {\n        engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);\n      }\n      var drawWrapper;\n      if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {\n        drawWrapper = subMesh._drawWrapper;\n      } else {\n        drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();\n      }\n      var effect = (_c = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c !== void 0 ? _c : null;\n      var _iterator8 = _createForOfIteratorHelper(scene._beforeRenderingMeshStage),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var step = _step8.value;\n          step.action(this, subMesh, batch, effect);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      if (!drawWrapper || !effect) {\n        if (oldCamera) {\n          oldCamera.maxZ = oldCameraMaxZ;\n          scene.updateTransformMatrix(true);\n        }\n        return this;\n      }\n      var effectiveMesh = effectiveMeshReplacement || this;\n      var sideOrientation;\n      if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {\n        var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n        sideOrientation = this.overrideMaterialSideOrientation;\n        if (sideOrientation == null) {\n          sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;\n        }\n        if (mainDeterminant < 0) {\n          sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n        }\n        instanceDataStorage.sideOrientation = sideOrientation;\n      } else {\n        sideOrientation = instanceDataStorage.sideOrientation;\n      }\n      var reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);\n      if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n      // Bind\n      var effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;\n      var fillMode = effectiveMaterial.fillMode;\n      if (this._internalMeshDataInfo._onBeforeBindObservable) {\n        this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);\n      }\n      if (!hardwareInstancedRendering) {\n        // Binding will be done later because we need to add more info to the VB\n        this._bind(subMesh, effect, fillMode, false);\n      }\n      var world = effectiveMesh.getWorldMatrix();\n      if (effectiveMaterial._storeEffectOnSubMeshes) {\n        effectiveMaterial.bindForSubMesh(world, this, subMesh);\n      } else {\n        effectiveMaterial.bind(world, this);\n      }\n      if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {\n        engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n        engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n        if (this._internalMeshDataInfo._onBetweenPassObservable) {\n          this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);\n        }\n      }\n      // Draw\n      this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n      // Unbind\n      this._internalMeshDataInfo._effectiveMaterial.unbind();\n      var _iterator9 = _createForOfIteratorHelper(scene._afterRenderingMeshStage),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step10 = _step9.value;\n          _step10.action(this, subMesh, batch, effect);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      if (this._internalMeshDataInfo._onAfterRenderObservable) {\n        this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);\n      }\n      if (oldCamera) {\n        oldCamera.maxZ = oldCameraMaxZ;\n        scene.updateTransformMatrix(true);\n      }\n      if (scene.performancePriority === ScenePerformancePriority.Aggressive && !instanceDataStorage.isFrozen) {\n        this._freeze();\n      }\n      return this;\n    }\n    /**\n     *   Renormalize the mesh and patch it up if there are no weights\n     *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.\n     *   However in the case of zero weights then we set just a single influence to 1.\n     *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.\n     */\n  }, {\n    key: \"cleanMatrixWeights\",\n    value: function cleanMatrixWeights() {\n      if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n          this._normalizeSkinWeightsAndExtra();\n        } else {\n          this._normalizeSkinFourWeights();\n        }\n      }\n    }\n    // faster 4 weight version.\n  }, {\n    key: \"_normalizeSkinFourWeights\",\n    value: function _normalizeSkinFourWeights() {\n      var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n      var numWeights = matricesWeights.length;\n      for (var a = 0; a < numWeights; a += 4) {\n        // accumulate weights\n        var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n        // check for invalid weight and just set it to 1.\n        if (t === 0) {\n          matricesWeights[a] = 1;\n        } else {\n          // renormalize so everything adds to 1 use reciprocal\n          var recip = 1 / t;\n          matricesWeights[a] *= recip;\n          matricesWeights[a + 1] *= recip;\n          matricesWeights[a + 2] *= recip;\n          matricesWeights[a + 3] *= recip;\n        }\n      }\n      this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n    }\n    // handle special case of extra verts.  (in theory gltf can handle 12 influences)\n  }, {\n    key: \"_normalizeSkinWeightsAndExtra\",\n    value: function _normalizeSkinWeightsAndExtra() {\n      var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n      var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n      var numWeights = matricesWeights.length;\n      for (var a = 0; a < numWeights; a += 4) {\n        // accumulate weights\n        var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n        t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];\n        // check for invalid weight and just set it to 1.\n        if (t === 0) {\n          matricesWeights[a] = 1;\n        } else {\n          // renormalize so everything adds to 1 use reciprocal\n          var recip = 1 / t;\n          matricesWeights[a] *= recip;\n          matricesWeights[a + 1] *= recip;\n          matricesWeights[a + 2] *= recip;\n          matricesWeights[a + 3] *= recip;\n          // same goes for extras\n          matricesWeightsExtra[a] *= recip;\n          matricesWeightsExtra[a + 1] *= recip;\n          matricesWeightsExtra[a + 2] *= recip;\n          matricesWeightsExtra[a + 3] *= recip;\n        }\n      }\n      this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n      this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);\n    }\n    /**\n     * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,\n     * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let\n     * the user know there was an issue with importing the mesh\n     * @returns a validation object with skinned, valid and report string\n     */\n  }, {\n    key: \"validateSkinning\",\n    value: function validateSkinning() {\n      var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n      var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n      if (matricesWeights === null || this.skeleton == null) {\n        return {\n          skinned: false,\n          valid: true,\n          report: \"not skinned\"\n        };\n      }\n      var numWeights = matricesWeights.length;\n      var numberNotSorted = 0;\n      var missingWeights = 0;\n      var maxUsedWeights = 0;\n      var numberNotNormalized = 0;\n      var numInfluences = matricesWeightsExtra === null ? 4 : 8;\n      var usedWeightCounts = new Array();\n      for (var a = 0; a <= numInfluences; a++) {\n        usedWeightCounts[a] = 0;\n      }\n      var toleranceEpsilon = 0.001;\n      for (var _a2 = 0; _a2 < numWeights; _a2 += 4) {\n        var lastWeight = matricesWeights[_a2];\n        var t = lastWeight;\n        var usedWeights = t === 0 ? 0 : 1;\n        for (var b = 1; b < numInfluences; b++) {\n          var d = b < 4 ? matricesWeights[_a2 + b] : matricesWeightsExtra[_a2 + b - 4];\n          if (d > lastWeight) {\n            numberNotSorted++;\n          }\n          if (d !== 0) {\n            usedWeights++;\n          }\n          t += d;\n          lastWeight = d;\n        }\n        // count the buffer weights usage\n        usedWeightCounts[usedWeights]++;\n        // max influences\n        if (usedWeights > maxUsedWeights) {\n          maxUsedWeights = usedWeights;\n        }\n        // check for invalid weight and just set it to 1.\n        if (t === 0) {\n          missingWeights++;\n        } else {\n          // renormalize so everything adds to 1 use reciprocal\n          var recip = 1 / t;\n          var tolerance = 0;\n          for (var _b2 = 0; _b2 < numInfluences; _b2++) {\n            if (_b2 < 4) {\n              tolerance += Math.abs(matricesWeights[_a2 + _b2] - matricesWeights[_a2 + _b2] * recip);\n            } else {\n              tolerance += Math.abs(matricesWeightsExtra[_a2 + _b2 - 4] - matricesWeightsExtra[_a2 + _b2 - 4] * recip);\n            }\n          }\n          // arbitrary epsilon value for dictating not normalized\n          if (tolerance > toleranceEpsilon) {\n            numberNotNormalized++;\n          }\n        }\n      }\n      // validate bone indices are in range of the skeleton\n      var numBones = this.skeleton.bones.length;\n      var matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n      var matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n      var numBadBoneIndices = 0;\n      for (var _a3 = 0; _a3 < numWeights; _a3 += 4) {\n        for (var _b3 = 0; _b3 < numInfluences; _b3++) {\n          var index = _b3 < 4 ? matricesIndices[_a3 + _b3] : matricesIndicesExtra[_a3 + _b3 - 4];\n          if (index >= numBones || index < 0) {\n            numBadBoneIndices++;\n          }\n        }\n      }\n      // log mesh stats\n      var output = \"Number of Weights = \" + numWeights / 4 + \"\\nMaximum influences = \" + maxUsedWeights + \"\\nMissing Weights = \" + missingWeights + \"\\nNot Sorted = \" + numberNotSorted + \"\\nNot Normalized = \" + numberNotNormalized + \"\\nWeightCounts = [\" + usedWeightCounts + \"]\" + \"\\nNumber of bones = \" + numBones + \"\\nBad Bone Indices = \" + numBadBoneIndices;\n      return {\n        skinned: true,\n        valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0,\n        report: output\n      };\n    }\n    /** @internal */\n  }, {\n    key: \"_checkDelayState\",\n    value: function _checkDelayState() {\n      var scene = this.getScene();\n      if (this._geometry) {\n        this._geometry.load(scene);\n      } else if (this.delayLoadState === 4) {\n        this.delayLoadState = 2;\n        this._queueLoad(scene);\n      }\n      return this;\n    }\n  }, {\n    key: \"_queueLoad\",\n    value: function _queueLoad(scene) {\n      var _this2 = this;\n      scene.addPendingData(this);\n      var getBinaryData = this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1;\n      Tools.LoadFile(this.delayLoadingFile, function (data) {\n        if (data instanceof ArrayBuffer) {\n          _this2._delayLoadingFunction(data, _this2);\n        } else {\n          _this2._delayLoadingFunction(JSON.parse(data), _this2);\n        }\n        _this2.instances.forEach(function (instance) {\n          instance.refreshBoundingInfo();\n          instance._syncSubMeshes();\n        });\n        _this2.delayLoadState = 1;\n        scene.removePendingData(_this2);\n      }, function () {}, scene.offlineProvider, getBinaryData);\n      return this;\n    }\n    /**\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n     * A mesh is in the frustum if its bounding box intersects the frustum\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the mesh is in the frustum planes\n     */\n  }, {\n    key: \"isInFrustum\",\n    value: function isInFrustum(frustumPlanes) {\n      if (this.delayLoadState === 2) {\n        return false;\n      }\n      if (!_get(_getPrototypeOf(Mesh.prototype), \"isInFrustum\", this).call(this, frustumPlanes)) {\n        return false;\n      }\n      this._checkDelayState();\n      return true;\n    }\n    /**\n     * Sets the mesh material by the material or multiMaterial `id` property\n     * @param id is a string identifying the material or the multiMaterial\n     * @returns the current mesh\n     */\n  }, {\n    key: \"setMaterialById\",\n    value: function setMaterialById(id) {\n      var materials = this.getScene().materials;\n      var index;\n      for (index = materials.length - 1; index > -1; index--) {\n        if (materials[index].id === id) {\n          this.material = materials[index];\n          return this;\n        }\n      }\n      // Multi\n      var multiMaterials = this.getScene().multiMaterials;\n      for (index = multiMaterials.length - 1; index > -1; index--) {\n        if (multiMaterials[index].id === id) {\n          this.material = multiMaterials[index];\n          return this;\n        }\n      }\n      return this;\n    }\n    /**\n     * Returns as a new array populated with the mesh material and/or skeleton, if any.\n     * @returns an array of IAnimatable\n     */\n  }, {\n    key: \"getAnimatables\",\n    value: function getAnimatables() {\n      var results = new Array();\n      if (this.material) {\n        results.push(this.material);\n      }\n      if (this.skeleton) {\n        results.push(this.skeleton);\n      }\n      return results;\n    }\n    /**\n     * Modifies the mesh geometry according to the passed transformation matrix.\n     * This method returns nothing, but it really modifies the mesh even if it's originally not set as updatable.\n     * The mesh normals are modified using the same transformation.\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\n     * @param transform defines the transform matrix to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n     * @returns the current mesh\n     */\n  }, {\n    key: \"bakeTransformIntoVertices\",\n    value: function bakeTransformIntoVertices(transform) {\n      // Position\n      if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n        return this;\n      }\n      var submeshes = this.subMeshes.splice(0);\n      this._resetPointsArrayCache();\n      var data = this.getVerticesData(VertexBuffer.PositionKind);\n      var temp = Vector3.Zero();\n      var index;\n      for (index = 0; index < data.length; index += 3) {\n        Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).toArray(data, index);\n      }\n      this.setVerticesData(VertexBuffer.PositionKind, data, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());\n      // Normals\n      if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n        data = this.getVerticesData(VertexBuffer.NormalKind);\n        for (index = 0; index < data.length; index += 3) {\n          Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).normalize().toArray(data, index);\n        }\n        this.setVerticesData(VertexBuffer.NormalKind, data, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());\n      }\n      // flip faces?\n      if (transform.determinant() < 0) {\n        this.flipFaces();\n      }\n      // Restore submeshes\n      this.releaseSubMeshes();\n      this.subMeshes = submeshes;\n      return this;\n    }\n    /**\n     * Modifies the mesh geometry according to its own current World Matrix.\n     * The mesh World Matrix is then reset.\n     * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n     * @param bakeIndependentlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking\n     * @returns the current mesh\n     */\n  }, {\n    key: \"bakeCurrentTransformIntoVertices\",\n    value: function bakeCurrentTransformIntoVertices() {\n      var bakeIndependentlyOfChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\n      this.resetLocalMatrix(bakeIndependentlyOfChildren);\n      return this;\n    }\n    // Cache\n    /** @internal */\n  }, {\n    key: \"_positions\",\n    get: function get() {\n      if (this._internalAbstractMeshDataInfo._positions) {\n        return this._internalAbstractMeshDataInfo._positions;\n      }\n      if (this._geometry) {\n        return this._geometry._positions;\n      }\n      return null;\n    }\n    /** @internal */\n  }, {\n    key: \"_resetPointsArrayCache\",\n    value: function _resetPointsArrayCache() {\n      if (this._geometry) {\n        this._geometry._resetPointsArrayCache();\n      }\n      return this;\n    }\n    /** @internal */\n  }, {\n    key: \"_generatePointsArray\",\n    value: function _generatePointsArray() {\n      if (this._geometry) {\n        return this._geometry._generatePointsArray();\n      }\n      return false;\n    }\n    /**\n     * Returns a new Mesh object generated from the current mesh properties.\n     * This method must not get confused with createInstance()\n     * @param name is a string, the name given to the new mesh\n     * @param newParent can be any Node object (default `null`)\n     * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)\n     * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)\n     * @returns a new mesh\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var newParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var doNotCloneChildren = arguments.length > 2 ? arguments[2] : undefined;\n      var clonePhysicsImpostor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\n    }\n    /**\n     * Releases resources associated with this mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose(doNotRecurse) {\n      var disposeMaterialAndTextures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.morphTargetManager = null;\n      if (this._geometry) {\n        this._geometry.releaseForMesh(this, true);\n      }\n      var internalDataInfo = this._internalMeshDataInfo;\n      if (internalDataInfo._onBeforeDrawObservable) {\n        internalDataInfo._onBeforeDrawObservable.clear();\n      }\n      if (internalDataInfo._onBeforeBindObservable) {\n        internalDataInfo._onBeforeBindObservable.clear();\n      }\n      if (internalDataInfo._onBeforeRenderObservable) {\n        internalDataInfo._onBeforeRenderObservable.clear();\n      }\n      if (internalDataInfo._onAfterRenderObservable) {\n        internalDataInfo._onAfterRenderObservable.clear();\n      }\n      if (internalDataInfo._onBetweenPassObservable) {\n        internalDataInfo._onBetweenPassObservable.clear();\n      }\n      // Sources\n      if (this._scene.useClonedMeshMap) {\n        if (internalDataInfo.meshMap) {\n          for (var uniqueId in internalDataInfo.meshMap) {\n            var mesh = internalDataInfo.meshMap[uniqueId];\n            if (mesh) {\n              mesh._internalMeshDataInfo._source = null;\n              internalDataInfo.meshMap[uniqueId] = undefined;\n            }\n          }\n        }\n        if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {\n          internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = undefined;\n        }\n      } else {\n        var meshes = this.getScene().meshes;\n        var _iterator10 = _createForOfIteratorHelper(meshes),\n          _step11;\n        try {\n          for (_iterator10.s(); !(_step11 = _iterator10.n()).done;) {\n            var abstractMesh = _step11.value;\n            var _mesh = abstractMesh;\n            if (_mesh._internalMeshDataInfo && _mesh._internalMeshDataInfo._source && _mesh._internalMeshDataInfo._source === this) {\n              _mesh._internalMeshDataInfo._source = null;\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n      internalDataInfo._source = null;\n      this._instanceDataStorage.visibleInstances = {};\n      // Instances\n      this._disposeInstanceSpecificData();\n      // Thin instances\n      this._disposeThinInstanceSpecificData();\n      if (this._internalMeshDataInfo._checkReadinessObserver) {\n        this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n      }\n      _get(_getPrototypeOf(Mesh.prototype), \"dispose\", this).call(this, doNotRecurse, disposeMaterialAndTextures);\n    }\n    /** @internal */\n  }, {\n    key: \"_disposeInstanceSpecificData\",\n    value: function _disposeInstanceSpecificData() {\n      // Do nothing\n    }\n    /** @internal */\n  }, {\n    key: \"_disposeThinInstanceSpecificData\",\n    value: function _disposeThinInstanceSpecificData() {\n      // Do nothing\n    }\n    /** @internal */\n  }, {\n    key: \"_invalidateInstanceVertexArrayObject\",\n    value: function _invalidateInstanceVertexArrayObject() {\n      // Do nothing\n    }\n    /**\n     * Modifies the mesh geometry according to a displacement map.\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n     * @param url is a string, the URL from the image file is to be downloaded.\n     * @param minHeight is the lower limit of the displacement.\n     * @param maxHeight is the upper limit of the displacement.\n     * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\n     * @param uvOffset is an optional vector2 used to offset UV.\n     * @param uvScale is an optional vector2 used to scale UV.\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n     * @returns the Mesh.\n     */\n  }, {\n    key: \"applyDisplacementMap\",\n    value: function applyDisplacementMap(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale) {\n      var _this3 = this;\n      var forceUpdate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var scene = this.getScene();\n      var onload = function onload(img) {\n        // Getting height map data\n        var heightMapWidth = img.width;\n        var heightMapHeight = img.height;\n        var canvas = _this3.getEngine().createCanvas(heightMapWidth, heightMapHeight);\n        var context = canvas.getContext(\"2d\");\n        context.drawImage(img, 0, 0);\n        // Create VertexData from map data\n        //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n        var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;\n        _this3.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);\n        //execute success callback, if set\n        if (onSuccess) {\n          onSuccess(_this3);\n        }\n      };\n      Tools.LoadImage(url, onload, function () {}, scene.offlineProvider);\n      return this;\n    }\n    /**\n     * Modifies the mesh geometry according to a displacementMap buffer.\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n     * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\n     * @param heightMapWidth is the width of the buffer image.\n     * @param heightMapHeight is the height of the buffer image.\n     * @param minHeight is the lower limit of the displacement.\n     * @param maxHeight is the upper limit of the displacement.\n     * @param uvOffset is an optional vector2 used to offset UV.\n     * @param uvScale is an optional vector2 used to scale UV.\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n     * @returns the Mesh.\n     */\n  }, {\n    key: \"applyDisplacementMapFromBuffer\",\n    value: function applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale) {\n      var forceUpdate = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n      if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        Logger.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\n        return this;\n      }\n      var positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);\n      var normals = this.getVerticesData(VertexBuffer.NormalKind);\n      var uvs = this.getVerticesData(VertexBuffer.UVKind);\n      var position = Vector3.Zero();\n      var normal = Vector3.Zero();\n      var uv = Vector2.Zero();\n      uvOffset = uvOffset || Vector2.Zero();\n      uvScale = uvScale || new Vector2(1, 1);\n      for (var index = 0; index < positions.length; index += 3) {\n        Vector3.FromArrayToRef(positions, index, position);\n        Vector3.FromArrayToRef(normals, index, normal);\n        Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);\n        // Compute height\n        var u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;\n        var v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;\n        var pos = (u + v * heightMapWidth) * 4;\n        var r = buffer[pos] / 255.0;\n        var g = buffer[pos + 1] / 255.0;\n        var b = buffer[pos + 2] / 255.0;\n        var gradient = r * 0.3 + g * 0.59 + b * 0.11;\n        normal.normalize();\n        normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\n        position = position.add(normal);\n        position.toArray(positions, index);\n      }\n      VertexData.ComputeNormals(positions, this.getIndices(), normals);\n      if (forceUpdate) {\n        this.setVerticesData(VertexBuffer.PositionKind, positions);\n        this.setVerticesData(VertexBuffer.NormalKind, normals);\n        this.setVerticesData(VertexBuffer.UVKind, uvs);\n      } else {\n        this.updateVerticesData(VertexBuffer.PositionKind, positions);\n        this.updateVerticesData(VertexBuffer.NormalKind, normals);\n      }\n      return this;\n    }\n    /**\n     * Modify the mesh to get a flat shading rendering.\n     * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\n     * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\n     * @returns current mesh\n     */\n  }, {\n    key: \"convertToFlatShadedMesh\",\n    value: function convertToFlatShadedMesh() {\n      var kinds = this.getVerticesDataKinds();\n      var vbs = {};\n      var data = {};\n      var newdata = {};\n      var updatableNormals = false;\n      var kindIndex;\n      var kind;\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        var vertexBuffer = this.getVertexBuffer(kind);\n        // Check data consistency\n        var vertexData = vertexBuffer.getData();\n        if (vertexData instanceof Array || vertexData instanceof Float32Array) {\n          if (vertexData.length === 0) {\n            continue;\n          }\n        }\n        if (kind === VertexBuffer.NormalKind) {\n          updatableNormals = vertexBuffer.isUpdatable();\n          kinds.splice(kindIndex, 1);\n          kindIndex--;\n          continue;\n        }\n        vbs[kind] = vertexBuffer;\n        data[kind] = this.getVerticesData(kind);\n        newdata[kind] = [];\n      }\n      // Save previous submeshes\n      var previousSubmeshes = this.subMeshes.slice(0);\n      var indices = this.getIndices();\n      var totalIndices = this.getTotalIndices();\n      // Generating unique vertices per face\n      var index;\n      for (index = 0; index < totalIndices; index++) {\n        var vertexIndex = indices[index];\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n          kind = kinds[kindIndex];\n          if (!vbs[kind]) {\n            continue;\n          }\n          var stride = vbs[kind].getStrideSize();\n          for (var offset = 0; offset < stride; offset++) {\n            newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n          }\n        }\n      }\n      // Updating faces & normal\n      var normals = [];\n      var positions = newdata[VertexBuffer.PositionKind];\n      var useRightHandedSystem = this.getScene().useRightHandedSystem;\n      var flipNormalGeneration;\n      if (useRightHandedSystem) {\n        flipNormalGeneration = this.overrideMaterialSideOrientation === 1;\n      } else {\n        flipNormalGeneration = this.overrideMaterialSideOrientation === 0;\n      }\n      for (index = 0; index < totalIndices; index += 3) {\n        indices[index] = index;\n        indices[index + 1] = index + 1;\n        indices[index + 2] = index + 2;\n        var p1 = Vector3.FromArray(positions, index * 3);\n        var p2 = Vector3.FromArray(positions, (index + 1) * 3);\n        var p3 = Vector3.FromArray(positions, (index + 2) * 3);\n        var p1p2 = p1.subtract(p2);\n        var p3p2 = p3.subtract(p2);\n        var normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));\n        if (flipNormalGeneration) {\n          normal.scaleInPlace(-1);\n        }\n        // Store same normals for every vertex\n        for (var localIndex = 0; localIndex < 3; localIndex++) {\n          normals.push(normal.x);\n          normals.push(normal.y);\n          normals.push(normal.z);\n        }\n      }\n      this.setIndices(indices);\n      this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);\n      // Updating vertex buffers\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        if (!newdata[kind]) {\n          continue;\n        }\n        this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n      }\n      // Updating submeshes\n      this.releaseSubMeshes();\n      for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n        var previousOne = previousSubmeshes[submeshIndex];\n        SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n      }\n      this.synchronizeInstances();\n      return this;\n    }\n    /**\n     * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\n     * In other words, more vertices, no more indices and a single bigger VBO.\n     * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\n     * @returns current mesh\n     */\n  }, {\n    key: \"convertToUnIndexedMesh\",\n    value: function convertToUnIndexedMesh() {\n      var kinds = this.getVerticesDataKinds();\n      var vbs = {};\n      var data = {};\n      var newdata = {};\n      var kindIndex;\n      var kind;\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        var vertexBuffer = this.getVertexBuffer(kind);\n        vbs[kind] = vertexBuffer;\n        data[kind] = vbs[kind].getData();\n        newdata[kind] = [];\n      }\n      // Save previous submeshes\n      var previousSubmeshes = this.subMeshes.slice(0);\n      var indices = this.getIndices();\n      var totalIndices = this.getTotalIndices();\n      // Generating unique vertices per face\n      var index;\n      for (index = 0; index < totalIndices; index++) {\n        var vertexIndex = indices[index];\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n          kind = kinds[kindIndex];\n          var stride = vbs[kind].getStrideSize();\n          for (var offset = 0; offset < stride; offset++) {\n            newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n          }\n        }\n      }\n      // Updating indices\n      for (index = 0; index < totalIndices; index += 3) {\n        indices[index] = index;\n        indices[index + 1] = index + 1;\n        indices[index + 2] = index + 2;\n      }\n      this.setIndices(indices);\n      // Updating vertex buffers\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable(), vbs[kind].getStrideSize());\n      }\n      // Updating submeshes\n      this.releaseSubMeshes();\n      for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n        var previousOne = previousSubmeshes[submeshIndex];\n        SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n      }\n      this._unIndexed = true;\n      this.synchronizeInstances();\n      return this;\n    }\n    /**\n     * Inverses facet orientations.\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     * @param flipNormals will also inverts the normals\n     * @returns current mesh\n     */\n  }, {\n    key: \"flipFaces\",\n    value: function flipFaces() {\n      var flipNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var vertex_data = VertexData.ExtractFromMesh(this);\n      var i;\n      if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {\n        for (i = 0; i < vertex_data.normals.length; i++) {\n          vertex_data.normals[i] *= -1;\n        }\n      }\n      if (vertex_data.indices) {\n        var temp;\n        for (i = 0; i < vertex_data.indices.length; i += 3) {\n          // reassign indices\n          temp = vertex_data.indices[i + 1];\n          vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\n          vertex_data.indices[i + 2] = temp;\n        }\n      }\n      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n      return this;\n    }\n    /**\n     * Increase the number of facets and hence vertices in a mesh\n     * Vertex normals are interpolated from existing vertex normals\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1\n     */\n  }, {\n    key: \"increaseVertices\",\n    value: function increaseVertices() {\n      var numberPerEdge = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var vertex_data = VertexData.ExtractFromMesh(this);\n      var currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;\n      var positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;\n      var uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;\n      var normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;\n      if (!currentIndices || !positions) {\n        Logger.Warn(\"Couldn't increase number of vertices : VertexData must contain at least indices and positions\");\n      } else {\n        vertex_data.indices = currentIndices;\n        vertex_data.positions = positions;\n        if (uvs) {\n          vertex_data.uvs = uvs;\n        }\n        if (normals) {\n          vertex_data.normals = normals;\n        }\n        var segments = numberPerEdge + 1; //segments per current facet edge, become sides of new facets\n        var tempIndices = new Array();\n        for (var i = 0; i < segments + 1; i++) {\n          tempIndices[i] = new Array();\n        }\n        var a; //vertex index of one end of a side\n        var b; //vertex index of other end of the side\n        var deltaPosition = new Vector3(0, 0, 0);\n        var deltaNormal = new Vector3(0, 0, 0);\n        var deltaUV = new Vector2(0, 0);\n        var indices = new Array();\n        var vertexIndex = new Array();\n        var side = new Array();\n        var len;\n        var positionPtr = positions.length;\n        var uvPtr;\n        if (uvs) {\n          uvPtr = uvs.length;\n        }\n        var normalsPtr;\n        if (normals) {\n          normalsPtr = normals.length;\n        }\n        for (var _i = 0; _i < currentIndices.length; _i += 3) {\n          vertexIndex[0] = currentIndices[_i];\n          vertexIndex[1] = currentIndices[_i + 1];\n          vertexIndex[2] = currentIndices[_i + 2];\n          for (var j = 0; j < 3; j++) {\n            a = vertexIndex[j];\n            b = vertexIndex[(j + 1) % 3];\n            if (side[a] === undefined && side[b] === undefined) {\n              side[a] = new Array();\n              side[b] = new Array();\n            } else {\n              if (side[a] === undefined) {\n                side[a] = new Array();\n              }\n              if (side[b] === undefined) {\n                side[b] = new Array();\n              }\n            }\n            if (side[a][b] === undefined && side[b][a] === undefined) {\n              side[a][b] = [];\n              deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;\n              deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;\n              deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;\n              if (normals) {\n                deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;\n                deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;\n                deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;\n              }\n              if (uvs) {\n                deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;\n                deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;\n              }\n              side[a][b].push(a);\n              for (var k = 1; k < segments; k++) {\n                side[a][b].push(positions.length / 3);\n                positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;\n                positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;\n                positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;\n                if (normals) {\n                  normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;\n                  normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;\n                  normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;\n                }\n                if (uvs) {\n                  uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;\n                  uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;\n                }\n              }\n              side[a][b].push(b);\n              side[b][a] = new Array();\n              len = side[a][b].length;\n              for (var idx = 0; idx < len; idx++) {\n                side[b][a][idx] = side[a][b][len - 1 - idx];\n              }\n            }\n          }\n          //Calculate positions, normals and uvs of new internal vertices\n          tempIndices[0][0] = currentIndices[_i];\n          tempIndices[1][0] = side[currentIndices[_i]][currentIndices[_i + 1]][1];\n          tempIndices[1][1] = side[currentIndices[_i]][currentIndices[_i + 2]][1];\n          for (var _k = 2; _k < segments; _k++) {\n            tempIndices[_k][0] = side[currentIndices[_i]][currentIndices[_i + 1]][_k];\n            tempIndices[_k][_k] = side[currentIndices[_i]][currentIndices[_i + 2]][_k];\n            deltaPosition.x = (positions[3 * tempIndices[_k][_k]] - positions[3 * tempIndices[_k][0]]) / _k;\n            deltaPosition.y = (positions[3 * tempIndices[_k][_k] + 1] - positions[3 * tempIndices[_k][0] + 1]) / _k;\n            deltaPosition.z = (positions[3 * tempIndices[_k][_k] + 2] - positions[3 * tempIndices[_k][0] + 2]) / _k;\n            if (normals) {\n              deltaNormal.x = (normals[3 * tempIndices[_k][_k]] - normals[3 * tempIndices[_k][0]]) / _k;\n              deltaNormal.y = (normals[3 * tempIndices[_k][_k] + 1] - normals[3 * tempIndices[_k][0] + 1]) / _k;\n              deltaNormal.z = (normals[3 * tempIndices[_k][_k] + 2] - normals[3 * tempIndices[_k][0] + 2]) / _k;\n            }\n            if (uvs) {\n              deltaUV.x = (uvs[2 * tempIndices[_k][_k]] - uvs[2 * tempIndices[_k][0]]) / _k;\n              deltaUV.y = (uvs[2 * tempIndices[_k][_k] + 1] - uvs[2 * tempIndices[_k][0] + 1]) / _k;\n            }\n            for (var _j = 1; _j < _k; _j++) {\n              tempIndices[_k][_j] = positions.length / 3;\n              positions[positionPtr++] = positions[3 * tempIndices[_k][0]] + _j * deltaPosition.x;\n              positions[positionPtr++] = positions[3 * tempIndices[_k][0] + 1] + _j * deltaPosition.y;\n              positions[positionPtr++] = positions[3 * tempIndices[_k][0] + 2] + _j * deltaPosition.z;\n              if (normals) {\n                normals[normalsPtr++] = normals[3 * tempIndices[_k][0]] + _j * deltaNormal.x;\n                normals[normalsPtr++] = normals[3 * tempIndices[_k][0] + 1] + _j * deltaNormal.y;\n                normals[normalsPtr++] = normals[3 * tempIndices[_k][0] + 2] + _j * deltaNormal.z;\n              }\n              if (uvs) {\n                uvs[uvPtr++] = uvs[2 * tempIndices[_k][0]] + _j * deltaUV.x;\n                uvs[uvPtr++] = uvs[2 * tempIndices[_k][0] + 1] + _j * deltaUV.y;\n              }\n            }\n          }\n          tempIndices[segments] = side[currentIndices[_i + 1]][currentIndices[_i + 2]];\n          // reform indices\n          indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);\n          for (var _k2 = 1; _k2 < segments; _k2++) {\n            var _j2 = void 0;\n            for (_j2 = 0; _j2 < _k2; _j2++) {\n              indices.push(tempIndices[_k2][_j2], tempIndices[_k2 + 1][_j2], tempIndices[_k2 + 1][_j2 + 1]);\n              indices.push(tempIndices[_k2][_j2], tempIndices[_k2 + 1][_j2 + 1], tempIndices[_k2][_j2 + 1]);\n            }\n            indices.push(tempIndices[_k2][_j2], tempIndices[_k2 + 1][_j2], tempIndices[_k2 + 1][_j2 + 1]);\n          }\n        }\n        vertex_data.indices = indices;\n        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n      }\n    }\n    /**\n     * Force adjacent facets to share vertices and remove any facets that have all vertices in a line\n     * This will undo any application of covertToFlatShadedMesh\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     */\n  }, {\n    key: \"forceSharedVertices\",\n    value: function forceSharedVertices() {\n      var vertex_data = VertexData.ExtractFromMesh(this);\n      var currentUVs = vertex_data.uvs;\n      var currentIndices = vertex_data.indices;\n      var currentPositions = vertex_data.positions;\n      var currentColors = vertex_data.colors;\n      var currentMatrixIndices = vertex_data.matricesIndices;\n      var currentMatrixWeights = vertex_data.matricesWeights;\n      var currentMatrixIndicesExtra = vertex_data.matricesIndicesExtra;\n      var currentMatrixWeightsExtra = vertex_data.matricesWeightsExtra;\n      if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {\n        Logger.Warn(\"VertexData contains empty entries\");\n      } else {\n        var positions = new Array();\n        var indices = new Array();\n        var uvs = new Array();\n        var colors = new Array();\n        var matrixIndices = new Array();\n        var matrixWeights = new Array();\n        var matrixIndicesExtra = new Array();\n        var matrixWeightsExtra = new Array();\n        var pstring = new Array(); //lists facet vertex positions (a,b,c) as string \"a|b|c\"\n        var indexPtr = 0; // pointer to next available index value\n        var uniquePositions = {}; // unique vertex positions\n        var ptr; // pointer to element in uniquePositions\n        var facet;\n        for (var i = 0; i < currentIndices.length; i += 3) {\n          facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]]; //facet vertex indices\n          pstring = new Array();\n          for (var j = 0; j < 3; j++) {\n            pstring[j] = \"\";\n            for (var k = 0; k < 3; k++) {\n              //small values make 0\n              if (Math.abs(currentPositions[3 * facet[j] + k]) < 0.00000001) {\n                currentPositions[3 * facet[j] + k] = 0;\n              }\n              pstring[j] += currentPositions[3 * facet[j] + k] + \"|\";\n            }\n          }\n          //check facet vertices to see that none are repeated\n          // do not process any facet that has a repeated vertex, ie is a line\n          if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {\n            //for each facet position check if already listed in uniquePositions\n            // if not listed add to uniquePositions and set index pointer\n            // if listed use its index in uniquePositions and new index pointer\n            for (var _j3 = 0; _j3 < 3; _j3++) {\n              ptr = uniquePositions[pstring[_j3]];\n              if (ptr === undefined) {\n                uniquePositions[pstring[_j3]] = indexPtr;\n                ptr = indexPtr++;\n                //not listed so add individual x, y, z coordinates to positions\n                for (var _k3 = 0; _k3 < 3; _k3++) {\n                  positions.push(currentPositions[3 * facet[_j3] + _k3]);\n                }\n                if (currentColors !== null && currentColors !== void 0) {\n                  for (var _k4 = 0; _k4 < 4; _k4++) {\n                    colors.push(currentColors[4 * facet[_j3] + _k4]);\n                  }\n                }\n                if (currentUVs !== null && currentUVs !== void 0) {\n                  for (var _k5 = 0; _k5 < 2; _k5++) {\n                    uvs.push(currentUVs[2 * facet[_j3] + _k5]);\n                  }\n                }\n                if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {\n                  for (var _k6 = 0; _k6 < 4; _k6++) {\n                    matrixIndices.push(currentMatrixIndices[4 * facet[_j3] + _k6]);\n                  }\n                }\n                if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n                  for (var _k7 = 0; _k7 < 4; _k7++) {\n                    matrixWeights.push(currentMatrixWeights[4 * facet[_j3] + _k7]);\n                  }\n                }\n                if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {\n                  for (var _k8 = 0; _k8 < 4; _k8++) {\n                    matrixIndicesExtra.push(currentMatrixIndicesExtra[4 * facet[_j3] + _k8]);\n                  }\n                }\n                if (currentMatrixWeightsExtra !== null && currentMatrixWeightsExtra !== void 0) {\n                  for (var _k9 = 0; _k9 < 4; _k9++) {\n                    matrixWeightsExtra.push(currentMatrixWeightsExtra[4 * facet[_j3] + _k9]);\n                  }\n                }\n              }\n              // add new index pointer to indices array\n              indices.push(ptr);\n            }\n          }\n        }\n        var normals = new Array();\n        VertexData.ComputeNormals(positions, indices, normals);\n        //create new vertex data object and update\n        vertex_data.positions = positions;\n        vertex_data.indices = indices;\n        vertex_data.normals = normals;\n        if (currentUVs !== null && currentUVs !== void 0) {\n          vertex_data.uvs = uvs;\n        }\n        if (currentColors !== null && currentColors !== void 0) {\n          vertex_data.colors = colors;\n        }\n        if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {\n          vertex_data.matricesIndices = matrixIndices;\n        }\n        if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n          vertex_data.matricesWeights = matrixWeights;\n        }\n        if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {\n          vertex_data.matricesIndicesExtra = matrixIndicesExtra;\n        }\n        if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n          vertex_data.matricesWeightsExtra = matrixWeightsExtra;\n        }\n        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n      }\n    }\n    // Instances\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/naming-convention\n  }, {\n    key: \"createInstance\",\n    value:\n    /**\n     * Creates a new InstancedMesh object from the mesh model.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n     * @param name defines the name of the new instance\n     * @returns a new InstancedMesh\n     */\n    function createInstance(name) {\n      return Mesh._instancedMeshFactory(name, this);\n    }\n    /**\n     * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\n     * After this call, all the mesh instances have the same submeshes than the current mesh.\n     * @returns the current mesh\n     */\n  }, {\n    key: \"synchronizeInstances\",\n    value: function synchronizeInstances() {\n      for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\n        var instance = this.instances[instanceIndex];\n        instance._syncSubMeshes();\n      }\n      return this;\n    }\n    /**\n     * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\n     * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\n     * This should be used together with the simplification to avoid disappearing triangles.\n     * @param successCallback an optional success callback to be called after the optimization finished.\n     * @returns the current mesh\n     */\n  }, {\n    key: \"optimizeIndices\",\n    value: function optimizeIndices(successCallback) {\n      var _this4 = this;\n      var indices = this.getIndices();\n      var positions = this.getVerticesData(VertexBuffer.PositionKind);\n      if (!positions || !indices) {\n        return this;\n      }\n      var vectorPositions = new Array();\n      for (var pos = 0; pos < positions.length; pos = pos + 3) {\n        vectorPositions.push(Vector3.FromArray(positions, pos));\n      }\n      var dupes = new Array();\n      AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function (iteration) {\n        var realPos = vectorPositions.length - 1 - iteration;\n        var testedPosition = vectorPositions[realPos];\n        for (var j = 0; j < realPos; ++j) {\n          var againstPosition = vectorPositions[j];\n          if (testedPosition.equals(againstPosition)) {\n            dupes[realPos] = j;\n            break;\n          }\n        }\n      }, function () {\n        for (var i = 0; i < indices.length; ++i) {\n          indices[i] = dupes[indices[i]] || indices[i];\n        }\n        //indices are now reordered\n        var originalSubMeshes = _this4.subMeshes.slice(0);\n        _this4.setIndices(indices);\n        _this4.subMeshes = originalSubMeshes;\n        if (successCallback) {\n          successCallback(_this4);\n        }\n      });\n      return this;\n    }\n    /**\n     * Serialize current mesh\n     * @param serializationObject defines the object which will receive the serialization data\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var serializationObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      serializationObject.name = this.name;\n      serializationObject.id = this.id;\n      serializationObject.uniqueId = this.uniqueId;\n      serializationObject.type = this.getClassName();\n      if (Tags && Tags.HasTags(this)) {\n        serializationObject.tags = Tags.GetTags(this);\n      }\n      serializationObject.position = this.position.asArray();\n      if (this.rotationQuaternion) {\n        serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\n      } else if (this.rotation) {\n        serializationObject.rotation = this.rotation.asArray();\n      }\n      serializationObject.scaling = this.scaling.asArray();\n      if (this._postMultiplyPivotMatrix) {\n        serializationObject.pivotMatrix = this.getPivotMatrix().asArray();\n      } else {\n        serializationObject.localMatrix = this.getPivotMatrix().asArray();\n      }\n      serializationObject.isEnabled = this.isEnabled(false);\n      serializationObject.isVisible = this.isVisible;\n      serializationObject.infiniteDistance = this.infiniteDistance;\n      serializationObject.pickable = this.isPickable;\n      serializationObject.receiveShadows = this.receiveShadows;\n      serializationObject.billboardMode = this.billboardMode;\n      serializationObject.visibility = this.visibility;\n      serializationObject.checkCollisions = this.checkCollisions;\n      serializationObject.isBlocker = this.isBlocker;\n      serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;\n      // Parent\n      if (this.parent) {\n        this.parent._serializeAsParent(serializationObject);\n      }\n      // Geometry\n      serializationObject.isUnIndexed = this.isUnIndexed;\n      var geometry = this._geometry;\n      if (geometry && this.subMeshes) {\n        serializationObject.geometryUniqueId = geometry.uniqueId;\n        serializationObject.geometryId = geometry.id;\n        // SubMeshes\n        serializationObject.subMeshes = [];\n        for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\n          var subMesh = this.subMeshes[subIndex];\n          serializationObject.subMeshes.push({\n            materialIndex: subMesh.materialIndex,\n            verticesStart: subMesh.verticesStart,\n            verticesCount: subMesh.verticesCount,\n            indexStart: subMesh.indexStart,\n            indexCount: subMesh.indexCount\n          });\n        }\n      }\n      // Material\n      if (this.material) {\n        if (!this.material.doNotSerialize) {\n          serializationObject.materialUniqueId = this.material.uniqueId;\n          serializationObject.materialId = this.material.id; // back compat\n        }\n      } else {\n        this.material = null;\n        serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;\n        serializationObject.materialId = this._scene.defaultMaterial.id; // back compat\n      }\n      // Morph targets\n      if (this.morphTargetManager) {\n        serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\n      }\n      // Skeleton\n      if (this.skeleton) {\n        serializationObject.skeletonId = this.skeleton.id;\n        serializationObject.numBoneInfluencers = this.numBoneInfluencers;\n      }\n      // Physics\n      //TODO implement correct serialization for physics impostors.\n      if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n        var impostor = this.getPhysicsImpostor();\n        if (impostor) {\n          serializationObject.physicsMass = impostor.getParam(\"mass\");\n          serializationObject.physicsFriction = impostor.getParam(\"friction\");\n          serializationObject.physicsRestitution = impostor.getParam(\"mass\");\n          serializationObject.physicsImpostor = impostor.type;\n        }\n      }\n      // Metadata\n      if (this.metadata) {\n        serializationObject.metadata = this.metadata;\n      }\n      // Instances\n      serializationObject.instances = [];\n      for (var index = 0; index < this.instances.length; index++) {\n        var instance = this.instances[index];\n        if (instance.doNotSerialize) {\n          continue;\n        }\n        var serializationInstance = {\n          name: instance.name,\n          id: instance.id,\n          isEnabled: instance.isEnabled(false),\n          isVisible: instance.isVisible,\n          isPickable: instance.isPickable,\n          checkCollisions: instance.checkCollisions,\n          position: instance.position.asArray(),\n          scaling: instance.scaling.asArray()\n        };\n        if (instance.parent) {\n          instance.parent._serializeAsParent(serializationInstance);\n        }\n        if (instance.rotationQuaternion) {\n          serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\n        } else if (instance.rotation) {\n          serializationInstance.rotation = instance.rotation.asArray();\n        }\n        // Physics\n        //TODO implement correct serialization for physics impostors.\n        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n          var _impostor = instance.getPhysicsImpostor();\n          if (_impostor) {\n            serializationInstance.physicsMass = _impostor.getParam(\"mass\");\n            serializationInstance.physicsFriction = _impostor.getParam(\"friction\");\n            serializationInstance.physicsRestitution = _impostor.getParam(\"mass\");\n            serializationInstance.physicsImpostor = _impostor.type;\n          }\n        }\n        // Metadata\n        if (instance.metadata) {\n          serializationInstance.metadata = instance.metadata;\n        }\n        // Action Manager\n        if (instance.actionManager) {\n          serializationInstance.actions = instance.actionManager.serialize(instance.name);\n        }\n        serializationObject.instances.push(serializationInstance);\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);\n        serializationInstance.ranges = instance.serializeAnimationRanges();\n      }\n      // Thin instances\n      if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {\n        serializationObject.thinInstances = {\n          instancesCount: this._thinInstanceDataStorage.instancesCount,\n          matrixData: Array.from(this._thinInstanceDataStorage.matrixData),\n          matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,\n          enablePicking: this.thinInstanceEnablePicking\n        };\n        if (this._userThinInstanceBuffersStorage) {\n          var userThinInstance = {\n            data: {},\n            sizes: {},\n            strides: {}\n          };\n          for (var kind in this._userThinInstanceBuffersStorage.data) {\n            userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);\n            userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];\n            userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];\n          }\n          serializationObject.thinInstances.userThinInstance = userThinInstance;\n        }\n      }\n      // Animations\n      SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n      serializationObject.ranges = this.serializeAnimationRanges();\n      // Layer mask\n      serializationObject.layerMask = this.layerMask;\n      // Alpha\n      serializationObject.alphaIndex = this.alphaIndex;\n      serializationObject.hasVertexAlpha = this.hasVertexAlpha;\n      // Overlay\n      serializationObject.overlayAlpha = this.overlayAlpha;\n      serializationObject.overlayColor = this.overlayColor.asArray();\n      serializationObject.renderOverlay = this.renderOverlay;\n      // Fog\n      serializationObject.applyFog = this.applyFog;\n      // Action Manager\n      if (this.actionManager) {\n        serializationObject.actions = this.actionManager.serialize(this.name);\n      }\n      return serializationObject;\n    }\n    /** @internal */\n  }, {\n    key: \"_syncGeometryWithMorphTargetManager\",\n    value: function _syncGeometryWithMorphTargetManager() {\n      if (!this.geometry) {\n        return;\n      }\n      this._markSubMeshesAsAttributesDirty();\n      var morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;\n      if (morphTargetManager && morphTargetManager.vertexCount) {\n        if (morphTargetManager.vertexCount !== this.getTotalVertices()) {\n          Logger.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\n          this.morphTargetManager = null;\n          return;\n        }\n        if (morphTargetManager.isUsingTextureForTargets) {\n          return;\n        }\n        for (var index = 0; index < morphTargetManager.numInfluencers; index++) {\n          var morphTarget = morphTargetManager.getActiveTarget(index);\n          var positions = morphTarget.getPositions();\n          if (!positions) {\n            Logger.Error(\"Invalid morph target. Target must have positions.\");\n            return;\n          }\n          this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);\n          var normals = morphTarget.getNormals();\n          if (normals) {\n            this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);\n          }\n          var tangents = morphTarget.getTangents();\n          if (tangents) {\n            this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);\n          }\n          var uvs = morphTarget.getUVs();\n          if (uvs) {\n            this.geometry.setVerticesData(VertexBuffer.UVKind + \"_\" + index, uvs, false, 2);\n          }\n        }\n      } else {\n        var _index2 = 0;\n        // Positions\n        while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + _index2)) {\n          this.geometry.removeVerticesData(VertexBuffer.PositionKind + _index2);\n          if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + _index2)) {\n            this.geometry.removeVerticesData(VertexBuffer.NormalKind + _index2);\n          }\n          if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + _index2)) {\n            this.geometry.removeVerticesData(VertexBuffer.TangentKind + _index2);\n          }\n          if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + _index2)) {\n            this.geometry.removeVerticesData(VertexBuffer.UVKind + \"_\" + _index2);\n          }\n          _index2++;\n        }\n      }\n    }\n    /**\n     * Returns a new Mesh object parsed from the source provided.\n     * @param parsedMesh is the source\n     * @param scene defines the hosting scene\n     * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with\n     * @returns a new Mesh\n     */\n  }, {\n    key: \"setPositionsForCPUSkinning\",\n    value:\n    // Skeletons\n    /**\n     * Prepare internal position array for software CPU skinning\n     * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh\n     */\n    function setPositionsForCPUSkinning() {\n      var internalDataInfo = this._internalMeshDataInfo;\n      if (!internalDataInfo._sourcePositions) {\n        var source = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!source) {\n          return internalDataInfo._sourcePositions;\n        }\n        internalDataInfo._sourcePositions = new Float32Array(source);\n        if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n          this.setVerticesData(VertexBuffer.PositionKind, source, true);\n        }\n      }\n      return internalDataInfo._sourcePositions;\n    }\n    /**\n     * Prepare internal normal array for software CPU skinning\n     * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.\n     */\n  }, {\n    key: \"setNormalsForCPUSkinning\",\n    value: function setNormalsForCPUSkinning() {\n      var internalDataInfo = this._internalMeshDataInfo;\n      if (!internalDataInfo._sourceNormals) {\n        var source = this.getVerticesData(VertexBuffer.NormalKind);\n        if (!source) {\n          return internalDataInfo._sourceNormals;\n        }\n        internalDataInfo._sourceNormals = new Float32Array(source);\n        if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n          this.setVerticesData(VertexBuffer.NormalKind, source, true);\n        }\n      }\n      return internalDataInfo._sourceNormals;\n    }\n    /**\n     * Updates the vertex buffer by applying transformation from the bones\n     * @param skeleton defines the skeleton to apply to current mesh\n     * @returns the current mesh\n     */\n  }, {\n    key: \"applySkeleton\",\n    value: function applySkeleton(skeleton) {\n      if (!this.geometry) {\n        return this;\n      }\n      if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {\n        return this;\n      }\n      this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();\n      if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n        return this;\n      }\n      if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n        return this;\n      }\n      if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n        return this;\n      }\n      var hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);\n      var internalDataInfo = this._internalMeshDataInfo;\n      if (!internalDataInfo._sourcePositions) {\n        var submeshes = this.subMeshes.slice();\n        this.setPositionsForCPUSkinning();\n        this.subMeshes = submeshes;\n      }\n      if (hasNormals && !internalDataInfo._sourceNormals) {\n        this.setNormalsForCPUSkinning();\n      }\n      // positionsData checks for not being Float32Array will only pass at most once\n      var positionsData = this.getVerticesData(VertexBuffer.PositionKind);\n      if (!positionsData) {\n        return this;\n      }\n      if (!(positionsData instanceof Float32Array)) {\n        positionsData = new Float32Array(positionsData);\n      }\n      // normalsData checks for not being Float32Array will only pass at most once\n      var normalsData = this.getVerticesData(VertexBuffer.NormalKind);\n      if (hasNormals) {\n        if (!normalsData) {\n          return this;\n        }\n        if (!(normalsData instanceof Float32Array)) {\n          normalsData = new Float32Array(normalsData);\n        }\n      }\n      var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n      var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n      if (!matricesWeightsData || !matricesIndicesData) {\n        return this;\n      }\n      var needExtras = this.numBoneInfluencers > 4;\n      var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n      var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n      var skeletonMatrices = skeleton.getTransformMatrices(this);\n      var tempVector3 = Vector3.Zero();\n      var finalMatrix = new Matrix();\n      var tempMatrix = new Matrix();\n      var matWeightIdx = 0;\n      var inf;\n      for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\n        var weight = void 0;\n        for (inf = 0; inf < 4; inf++) {\n          weight = matricesWeightsData[matWeightIdx + inf];\n          if (weight > 0) {\n            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n            finalMatrix.addToSelf(tempMatrix);\n          }\n        }\n        if (needExtras) {\n          for (inf = 0; inf < 4; inf++) {\n            weight = matricesWeightsExtraData[matWeightIdx + inf];\n            if (weight > 0) {\n              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n              finalMatrix.addToSelf(tempMatrix);\n            }\n          }\n        }\n        Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);\n        tempVector3.toArray(positionsData, index);\n        if (hasNormals) {\n          Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);\n          tempVector3.toArray(normalsData, index);\n        }\n        finalMatrix.reset();\n      }\n      this.updateVerticesData(VertexBuffer.PositionKind, positionsData);\n      if (hasNormals) {\n        this.updateVerticesData(VertexBuffer.NormalKind, normalsData);\n      }\n      return this;\n    }\n    // Tools\n    /**\n     * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates\n     * @param meshes defines the list of meshes to scan\n     * @returns an object `{min:` Vector3`, max:` Vector3`}`\n     */\n  }, {\n    key: \"addInstance\",\n    value:\n    /**\n     * @internal\n     */\n    function addInstance(instance) {\n      instance._indexInSourceMeshInstanceArray = this.instances.length;\n      this.instances.push(instance);\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"removeInstance\",\n    value: function removeInstance(instance) {\n      // Remove from mesh\n      var index = instance._indexInSourceMeshInstanceArray;\n      if (index != -1) {\n        if (index !== this.instances.length - 1) {\n          var last = this.instances[this.instances.length - 1];\n          this.instances[index] = last;\n          last._indexInSourceMeshInstanceArray = index;\n        }\n        instance._indexInSourceMeshInstanceArray = -1;\n        this.instances.pop();\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_shouldConvertRHS\",\n    value: function _shouldConvertRHS() {\n      return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;\n    }\n    /** @internal */\n  }, {\n    key: \"_getRenderingFillMode\",\n    value: function _getRenderingFillMode(fillMode) {\n      var _a;\n      var scene = this.getScene();\n      if (scene.forcePointsCloud) return Material.PointFillMode;\n      if (scene.forceWireframe) return Material.WireFrameFillMode;\n      return (_a = this.overrideRenderingFillMode) !== null && _a !== void 0 ? _a : fillMode;\n    }\n  }], [{\n    key: \"_GetDefaultSideOrientation\",\n    value:\n    /**\n     * Gets the default side orientation.\n     * @param orientation the orientation to value to attempt to get\n     * @returns the default orientation\n     * @internal\n     */\n    function _GetDefaultSideOrientation(orientation) {\n      return orientation || Mesh.FRONTSIDE; // works as Mesh.FRONTSIDE is 0\n    }\n  }, {\n    key: \"_instancedMeshFactory\",\n    value: function _instancedMeshFactory(name, mesh) {\n      throw _WarnImport(\"InstancedMesh\");\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  }, {\n    key: \"_PhysicsImpostorParser\",\n    value: function _PhysicsImpostorParser(scene, physicObject, jsonObject) {\n      throw _WarnImport(\"PhysicsImpostor\");\n    }\n  }, {\n    key: \"Parse\",\n    value: function Parse(parsedMesh, scene, rootUrl) {\n      var mesh;\n      if (parsedMesh.type && parsedMesh.type === \"LinesMesh\") {\n        mesh = Mesh._LinesMeshParser(parsedMesh, scene);\n      } else if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\n        mesh = Mesh._GroundMeshParser(parsedMesh, scene);\n      } else if (parsedMesh.type && parsedMesh.type === \"GoldbergMesh\") {\n        mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);\n      } else {\n        mesh = new Mesh(parsedMesh.name, scene);\n      }\n      mesh.id = parsedMesh.id;\n      mesh._waitingParsedUniqueId = parsedMesh.uniqueId;\n      if (Tags) {\n        Tags.AddTagsTo(mesh, parsedMesh.tags);\n      }\n      mesh.position = Vector3.FromArray(parsedMesh.position);\n      if (parsedMesh.metadata !== undefined) {\n        mesh.metadata = parsedMesh.metadata;\n      }\n      if (parsedMesh.rotationQuaternion) {\n        mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);\n      } else if (parsedMesh.rotation) {\n        mesh.rotation = Vector3.FromArray(parsedMesh.rotation);\n      }\n      mesh.scaling = Vector3.FromArray(parsedMesh.scaling);\n      if (parsedMesh.localMatrix) {\n        mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));\n      } else if (parsedMesh.pivotMatrix) {\n        mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));\n      }\n      mesh.setEnabled(parsedMesh.isEnabled);\n      mesh.isVisible = parsedMesh.isVisible;\n      mesh.infiniteDistance = parsedMesh.infiniteDistance;\n      mesh.showBoundingBox = parsedMesh.showBoundingBox;\n      mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\n      if (parsedMesh.applyFog !== undefined) {\n        mesh.applyFog = parsedMesh.applyFog;\n      }\n      if (parsedMesh.pickable !== undefined) {\n        mesh.isPickable = parsedMesh.pickable;\n      }\n      if (parsedMesh.alphaIndex !== undefined) {\n        mesh.alphaIndex = parsedMesh.alphaIndex;\n      }\n      mesh.receiveShadows = parsedMesh.receiveShadows;\n      if (parsedMesh.billboardMode !== undefined) {\n        mesh.billboardMode = parsedMesh.billboardMode;\n      }\n      if (parsedMesh.visibility !== undefined) {\n        mesh.visibility = parsedMesh.visibility;\n      }\n      mesh.checkCollisions = parsedMesh.checkCollisions;\n      mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;\n      if (parsedMesh.isBlocker !== undefined) {\n        mesh.isBlocker = parsedMesh.isBlocker;\n      }\n      mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;\n      // freezeWorldMatrix\n      if (parsedMesh.freezeWorldMatrix) {\n        mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;\n      }\n      // Parent\n      if (parsedMesh.parentId !== undefined) {\n        mesh._waitingParentId = parsedMesh.parentId;\n      }\n      if (parsedMesh.parentInstanceIndex !== undefined) {\n        mesh._waitingParentInstanceIndex = parsedMesh.parentInstanceIndex;\n      }\n      // Actions\n      if (parsedMesh.actions !== undefined) {\n        mesh._waitingData.actions = parsedMesh.actions;\n      }\n      // Overlay\n      if (parsedMesh.overlayAlpha !== undefined) {\n        mesh.overlayAlpha = parsedMesh.overlayAlpha;\n      }\n      if (parsedMesh.overlayColor !== undefined) {\n        mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);\n      }\n      if (parsedMesh.renderOverlay !== undefined) {\n        mesh.renderOverlay = parsedMesh.renderOverlay;\n      }\n      // Geometry\n      mesh.isUnIndexed = !!parsedMesh.isUnIndexed;\n      mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\n      if (parsedMesh.delayLoadingFile) {\n        mesh.delayLoadState = 4;\n        mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\n        mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));\n        if (parsedMesh._binaryInfo) {\n          mesh._binaryInfo = parsedMesh._binaryInfo;\n        }\n        mesh._delayInfo = [];\n        if (parsedMesh.hasUVs) {\n          mesh._delayInfo.push(VertexBuffer.UVKind);\n        }\n        if (parsedMesh.hasUVs2) {\n          mesh._delayInfo.push(VertexBuffer.UV2Kind);\n        }\n        if (parsedMesh.hasUVs3) {\n          mesh._delayInfo.push(VertexBuffer.UV3Kind);\n        }\n        if (parsedMesh.hasUVs4) {\n          mesh._delayInfo.push(VertexBuffer.UV4Kind);\n        }\n        if (parsedMesh.hasUVs5) {\n          mesh._delayInfo.push(VertexBuffer.UV5Kind);\n        }\n        if (parsedMesh.hasUVs6) {\n          mesh._delayInfo.push(VertexBuffer.UV6Kind);\n        }\n        if (parsedMesh.hasColors) {\n          mesh._delayInfo.push(VertexBuffer.ColorKind);\n        }\n        if (parsedMesh.hasMatricesIndices) {\n          mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n        }\n        if (parsedMesh.hasMatricesWeights) {\n          mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n        }\n        mesh._delayLoadingFunction = Geometry._ImportGeometry;\n        if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\n          mesh._checkDelayState();\n        }\n      } else {\n        Geometry._ImportGeometry(parsedMesh, mesh);\n      }\n      // Material\n      if (parsedMesh.materialUniqueId) {\n        mesh._waitingMaterialId = parsedMesh.materialUniqueId;\n      } else if (parsedMesh.materialId) {\n        mesh._waitingMaterialId = parsedMesh.materialId;\n      }\n      // Morph targets\n      if (parsedMesh.morphTargetManagerId > -1) {\n        mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\n      }\n      // Skeleton\n      if (parsedMesh.skeletonId !== undefined && parsedMesh.skeletonId !== null) {\n        mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);\n        if (parsedMesh.numBoneInfluencers) {\n          mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\n        }\n      }\n      // Animations\n      if (parsedMesh.animations) {\n        for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\n          var parsedAnimation = parsedMesh.animations[animationIndex];\n          var internalClass = GetClass(\"BABYLON.Animation\");\n          if (internalClass) {\n            mesh.animations.push(internalClass.Parse(parsedAnimation));\n          }\n        }\n        Node.ParseAnimationRanges(mesh, parsedMesh, scene);\n      }\n      if (parsedMesh.autoAnimate) {\n        scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\n      }\n      // Layer Mask\n      if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {\n        mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\n      } else {\n        mesh.layerMask = 0x0fffffff;\n      }\n      // Physics\n      if (parsedMesh.physicsImpostor) {\n        Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);\n      }\n      // Levels\n      if (parsedMesh.lodMeshIds) {\n        mesh._waitingData.lods = {\n          ids: parsedMesh.lodMeshIds,\n          distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,\n          coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null\n        };\n      }\n      // Instances\n      if (parsedMesh.instances) {\n        for (var index = 0; index < parsedMesh.instances.length; index++) {\n          var parsedInstance = parsedMesh.instances[index];\n          var instance = mesh.createInstance(parsedInstance.name);\n          if (parsedInstance.id) {\n            instance.id = parsedInstance.id;\n          }\n          if (Tags) {\n            if (parsedInstance.tags) {\n              Tags.AddTagsTo(instance, parsedInstance.tags);\n            } else {\n              Tags.AddTagsTo(instance, parsedMesh.tags);\n            }\n          }\n          instance.position = Vector3.FromArray(parsedInstance.position);\n          if (parsedInstance.metadata !== undefined) {\n            instance.metadata = parsedInstance.metadata;\n          }\n          if (parsedInstance.parentId !== undefined) {\n            instance._waitingParentId = parsedInstance.parentId;\n          }\n          if (parsedInstance.parentInstanceIndex !== undefined) {\n            instance._waitingParentInstanceIndex = parsedInstance.parentInstanceIndex;\n          }\n          if (parsedInstance.isEnabled !== undefined && parsedInstance.isEnabled !== null) {\n            instance.setEnabled(parsedInstance.isEnabled);\n          }\n          if (parsedInstance.isVisible !== undefined && parsedInstance.isVisible !== null) {\n            instance.isVisible = parsedInstance.isVisible;\n          }\n          if (parsedInstance.isPickable !== undefined && parsedInstance.isPickable !== null) {\n            instance.isPickable = parsedInstance.isPickable;\n          }\n          if (parsedInstance.rotationQuaternion) {\n            instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);\n          } else if (parsedInstance.rotation) {\n            instance.rotation = Vector3.FromArray(parsedInstance.rotation);\n          }\n          instance.scaling = Vector3.FromArray(parsedInstance.scaling);\n          if (parsedInstance.checkCollisions != undefined && parsedInstance.checkCollisions != null) {\n            instance.checkCollisions = parsedInstance.checkCollisions;\n          }\n          if (parsedInstance.pickable != undefined && parsedInstance.pickable != null) {\n            instance.isPickable = parsedInstance.pickable;\n          }\n          if (parsedInstance.showBoundingBox != undefined && parsedInstance.showBoundingBox != null) {\n            instance.showBoundingBox = parsedInstance.showBoundingBox;\n          }\n          if (parsedInstance.showSubMeshesBoundingBox != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n            instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;\n          }\n          if (parsedInstance.alphaIndex != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n            instance.alphaIndex = parsedInstance.alphaIndex;\n          }\n          // Physics\n          if (parsedInstance.physicsImpostor) {\n            Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);\n          }\n          // Actions\n          if (parsedInstance.actions !== undefined) {\n            instance._waitingData.actions = parsedInstance.actions;\n          }\n          // Animation\n          if (parsedInstance.animations) {\n            for (var _animationIndex = 0; _animationIndex < parsedInstance.animations.length; _animationIndex++) {\n              var _parsedAnimation = parsedInstance.animations[_animationIndex];\n              var _internalClass = GetClass(\"BABYLON.Animation\");\n              if (_internalClass) {\n                instance.animations.push(_internalClass.Parse(_parsedAnimation));\n              }\n            }\n            Node.ParseAnimationRanges(instance, parsedInstance, scene);\n            if (parsedInstance.autoAnimate) {\n              scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1.0);\n            }\n          }\n        }\n      }\n      // Thin instances\n      if (parsedMesh.thinInstances) {\n        var thinInstances = parsedMesh.thinInstances;\n        mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;\n        if (thinInstances.matrixData) {\n          mesh.thinInstanceSetBuffer(\"matrix\", new Float32Array(thinInstances.matrixData), 16, false);\n          mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n          mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;\n        } else {\n          mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n        }\n        if (parsedMesh.thinInstances.userThinInstance) {\n          var userThinInstance = parsedMesh.thinInstances.userThinInstance;\n          for (var kind in userThinInstance.data) {\n            mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);\n            mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];\n          }\n        }\n      }\n      return mesh;\n    }\n  }, {\n    key: \"MinMax\",\n    value: function MinMax(meshes) {\n      var minVector = null;\n      var maxVector = null;\n      meshes.forEach(function (mesh) {\n        var boundingInfo = mesh.getBoundingInfo();\n        var boundingBox = boundingInfo.boundingBox;\n        if (!minVector || !maxVector) {\n          minVector = boundingBox.minimumWorld;\n          maxVector = boundingBox.maximumWorld;\n        } else {\n          minVector.minimizeInPlace(boundingBox.minimumWorld);\n          maxVector.maximizeInPlace(boundingBox.maximumWorld);\n        }\n      });\n      if (!minVector || !maxVector) {\n        return {\n          min: Vector3.Zero(),\n          max: Vector3.Zero()\n        };\n      }\n      return {\n        min: minVector,\n        max: maxVector\n      };\n    }\n    /**\n     * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array\n     * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object\n     * @returns a vector3\n     */\n  }, {\n    key: \"Center\",\n    value: function Center(meshesOrMinMaxVector) {\n      var minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\n      return Vector3.Center(minMaxVector.min, minMaxVector.max);\n    }\n    /**\n     * Merge the array of meshes into a single mesh for performance reasons.\n     * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n     * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n     * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n     * @returns a new mesh\n     */\n  }, {\n    key: \"MergeMeshes\",\n    value: function MergeMeshes(meshes) {\n      var disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n      var meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n      var subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n      var multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n      return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));\n    }\n    /**\n     * Merge the array of meshes into a single mesh for performance reasons.\n     * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n     * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n     * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n     * @returns a new mesh\n     */\n  }, {\n    key: \"MergeMeshesAsync\",\n    value: function MergeMeshesAsync(meshes) {\n      var disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n      var meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n      var subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n      var multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n      return runCoroutineAsync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());\n    }\n  }, {\n    key: \"_MergeMeshesCoroutine\",\n    value: function _MergeMeshesCoroutine(meshes) {\n      var disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n      var meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n      var subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n      var multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n      var isAsync = arguments.length > 6 ? arguments[6] : undefined;\n      return /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var index, totalVertices, materialArray, materialIndexArray, indiceArray, currentOverrideMaterialSideOrientation, mesh, material, matIndex, subIndex, _subIndex, _subIndex2, source, getVertexDataFromMesh, _getVertexDataFromMes, sourceVertexData, sourceTransform, meshVertexDatas, i, mergeCoroutine, mergeCoroutineStep, vertexData, applyToCoroutine, applyToCoroutineStep, offset, _iterator11, _step12, subMesh, newMultiMaterial, _subIndex3;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // Remove any null/undefined entries from the mesh array\n              meshes = meshes.filter(Boolean);\n              if (!(meshes.length === 0)) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt(\"return\", null);\n            case 3:\n              if (allow32BitsIndices) {\n                _context.next = 14;\n                break;\n              }\n              totalVertices = 0; // Counting vertices\n              index = 0;\n            case 6:\n              if (!(index < meshes.length)) {\n                _context.next = 14;\n                break;\n              }\n              totalVertices += meshes[index].getTotalVertices();\n              if (!(totalVertices >= 65536)) {\n                _context.next = 11;\n                break;\n              }\n              Logger.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\n              return _context.abrupt(\"return\", null);\n            case 11:\n              index++;\n              _context.next = 6;\n              break;\n            case 14:\n              if (multiMultiMaterials) {\n                subdivideWithSubMeshes = false;\n              }\n              materialArray = new Array();\n              materialIndexArray = new Array(); // Merge\n              indiceArray = new Array();\n              currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;\n              index = 0;\n            case 20:\n              if (!(index < meshes.length)) {\n                _context.next = 33;\n                break;\n              }\n              mesh = meshes[index];\n              if (!mesh.isAnInstance) {\n                _context.next = 25;\n                break;\n              }\n              Logger.Warn(\"Cannot merge instance meshes.\");\n              return _context.abrupt(\"return\", null);\n            case 25:\n              if (!(currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation)) {\n                _context.next = 28;\n                break;\n              }\n              Logger.Warn(\"Cannot merge meshes with different overrideMaterialSideOrientation values.\");\n              return _context.abrupt(\"return\", null);\n            case 28:\n              if (subdivideWithSubMeshes) {\n                indiceArray.push(mesh.getTotalIndices());\n              }\n              if (multiMultiMaterials) {\n                if (mesh.material) {\n                  material = mesh.material;\n                  if (material instanceof MultiMaterial) {\n                    for (matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {\n                      if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {\n                        materialArray.push(material.subMaterials[matIndex]);\n                      }\n                    }\n                    for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                      materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));\n                      indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n                    }\n                  } else {\n                    if (materialArray.indexOf(material) < 0) {\n                      materialArray.push(material);\n                    }\n                    for (_subIndex = 0; _subIndex < mesh.subMeshes.length; _subIndex++) {\n                      materialIndexArray.push(materialArray.indexOf(material));\n                      indiceArray.push(mesh.subMeshes[_subIndex].indexCount);\n                    }\n                  }\n                } else {\n                  for (_subIndex2 = 0; _subIndex2 < mesh.subMeshes.length; _subIndex2++) {\n                    materialIndexArray.push(0);\n                    indiceArray.push(mesh.subMeshes[_subIndex2].indexCount);\n                  }\n                }\n              }\n            case 30:\n              index++;\n              _context.next = 20;\n              break;\n            case 33:\n              source = meshes[0];\n              getVertexDataFromMesh = function getVertexDataFromMesh(mesh) {\n                var wm = mesh.computeWorldMatrix(true);\n                var vertexData = VertexData.ExtractFromMesh(mesh, false, false);\n                return {\n                  vertexData: vertexData,\n                  transform: wm\n                };\n              };\n              _getVertexDataFromMes = getVertexDataFromMesh(source), sourceVertexData = _getVertexDataFromMes.vertexData, sourceTransform = _getVertexDataFromMes.transform;\n              if (!isAsync) {\n                _context.next = 39;\n                break;\n              }\n              _context.next = 39;\n              return;\n            case 39:\n              meshVertexDatas = new Array(meshes.length - 1);\n              i = 1;\n            case 41:\n              if (!(i < meshes.length)) {\n                _context.next = 49;\n                break;\n              }\n              meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);\n              if (!isAsync) {\n                _context.next = 46;\n                break;\n              }\n              _context.next = 46;\n              return;\n            case 46:\n              i++;\n              _context.next = 41;\n              break;\n            case 49:\n              mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);\n              mergeCoroutineStep = mergeCoroutine.next();\n            case 51:\n              if (mergeCoroutineStep.done) {\n                _context.next = 58;\n                break;\n              }\n              if (!isAsync) {\n                _context.next = 55;\n                break;\n              }\n              _context.next = 55;\n              return;\n            case 55:\n              mergeCoroutineStep = mergeCoroutine.next();\n              _context.next = 51;\n              break;\n            case 58:\n              vertexData = mergeCoroutineStep.value;\n              if (!meshSubclass) {\n                meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\n              }\n              applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, undefined, isAsync);\n              applyToCoroutineStep = applyToCoroutine.next();\n            case 62:\n              if (applyToCoroutineStep.done) {\n                _context.next = 69;\n                break;\n              }\n              if (!isAsync) {\n                _context.next = 66;\n                break;\n              }\n              _context.next = 66;\n              return;\n            case 66:\n              applyToCoroutineStep = applyToCoroutine.next();\n              _context.next = 62;\n              break;\n            case 69:\n              // Setting properties\n              meshSubclass.checkCollisions = source.checkCollisions;\n              meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;\n              // Cleaning\n              if (disposeSource) {\n                for (index = 0; index < meshes.length; index++) {\n                  meshes[index].dispose();\n                }\n              }\n              // Subdivide\n              if (subdivideWithSubMeshes || multiMultiMaterials) {\n                //-- removal of global submesh\n                meshSubclass.releaseSubMeshes();\n                index = 0;\n                offset = 0; //-- apply subdivision according to index table\n                while (index < indiceArray.length) {\n                  SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, undefined, false);\n                  offset += indiceArray[index];\n                  index++;\n                }\n                _iterator11 = _createForOfIteratorHelper(meshSubclass.subMeshes);\n                try {\n                  for (_iterator11.s(); !(_step12 = _iterator11.n()).done;) {\n                    subMesh = _step12.value;\n                    subMesh.refreshBoundingInfo();\n                  }\n                } catch (err) {\n                  _iterator11.e(err);\n                } finally {\n                  _iterator11.f();\n                }\n                meshSubclass.computeWorldMatrix(true);\n              }\n              if (multiMultiMaterials) {\n                newMultiMaterial = new MultiMaterial(source.name + \"_merged\", source.getScene());\n                newMultiMaterial.subMaterials = materialArray;\n                for (_subIndex3 = 0; _subIndex3 < meshSubclass.subMeshes.length; _subIndex3++) {\n                  meshSubclass.subMeshes[_subIndex3].materialIndex = materialIndexArray[_subIndex3];\n                }\n                meshSubclass.material = newMultiMaterial;\n              } else {\n                meshSubclass.material = source.material;\n              }\n              return _context.abrupt(\"return\", meshSubclass);\n            case 75:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      })();\n    }\n  }]);\n  return Mesh;\n}(AbstractMesh);\n// Consts\n/**\n * Mesh side orientation : usually the external or front surface\n */\nMesh.FRONTSIDE = VertexData.FRONTSIDE;\n/**\n * Mesh side orientation : usually the internal or back surface\n */\nMesh.BACKSIDE = VertexData.BACKSIDE;\n/**\n * Mesh side orientation : both internal and external or front and back surfaces\n */\nMesh.DOUBLESIDE = VertexData.DOUBLESIDE;\n/**\n * Mesh side orientation : by default, `FRONTSIDE`\n */\nMesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;\n/**\n * Mesh cap setting : no cap\n */\nMesh.NO_CAP = 0;\n/**\n * Mesh cap setting : one cap at the beginning of the mesh\n */\nMesh.CAP_START = 1;\n/**\n * Mesh cap setting : one cap at the end of the mesh\n */\nMesh.CAP_END = 2;\n/**\n * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\n */\nMesh.CAP_ALL = 3;\n/**\n * Mesh pattern setting : no flip or rotate\n */\nMesh.NO_FLIP = 0;\n/**\n * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column\n */\nMesh.FLIP_TILE = 1;\n/**\n * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column\n */\nMesh.ROTATE_TILE = 2;\n/**\n * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows\n */\nMesh.FLIP_ROW = 3;\n/**\n * Mesh pattern setting : rotate (180degs) all tiles on alternate rows\n */\nMesh.ROTATE_ROW = 4;\n/**\n * Mesh pattern setting : flip and rotate alternate tiles on each row or column\n */\nMesh.FLIP_N_ROTATE_TILE = 5;\n/**\n * Mesh pattern setting : rotate pattern and rotate\n */\nMesh.FLIP_N_ROTATE_ROW = 6;\n/**\n * Mesh tile positioning : part tiles same on left/right or top/bottom\n */\nMesh.CENTER = 0;\n/**\n * Mesh tile positioning : part tiles on left\n */\nMesh.LEFT = 1;\n/**\n * Mesh tile positioning : part tiles on right\n */\nMesh.RIGHT = 2;\n/**\n * Mesh tile positioning : part tiles on top\n */\nMesh.TOP = 3;\n/**\n * Mesh tile positioning : part tiles on bottom\n */\nMesh.BOTTOM = 4;\n/**\n * Indicates that the instanced meshes should be sorted from back to front before rendering if their material is transparent\n */\nMesh.INSTANCEDMESH_SORT_TRANSPARENT = false;\n// Statics\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GroundMeshParser = function (parsedMesh, scene) {\n  throw _WarnImport(\"GroundMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GoldbergMeshParser = function (parsedMesh, scene) {\n  throw _WarnImport(\"GoldbergMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._LinesMeshParser = function (parsedMesh, scene) {\n  throw _WarnImport(\"LinesMesh\");\n};\nRegisterClass(\"BABYLON.Mesh\", Mesh);\n/**\n * @internal\n */\nMesh.prototype.setMaterialByID = function (id) {\n  return this.setMaterialById(id);\n};\nMesh.CreateDisc = Mesh.CreateDisc || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateBox = Mesh.CreateBox || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateSphere = Mesh.CreateSphere || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateCylinder = Mesh.CreateCylinder || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateTorusKnot = Mesh.CreateTorusKnot || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateTorus = Mesh.CreateTorus || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreatePlane = Mesh.CreatePlane || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateGround = Mesh.CreateGround || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateTiledGround = Mesh.CreateTiledGround || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateGroundFromHeightMap = Mesh.CreateGroundFromHeightMap || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateTube = Mesh.CreateTube || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreatePolyhedron = Mesh.CreatePolyhedron || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateIcoSphere = Mesh.CreateIcoSphere || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateDecal = Mesh.CreateDecal || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.CreateCapsule = Mesh.CreateCapsule || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\nMesh.ExtendToGoldberg = Mesh.ExtendToGoldberg || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};"],"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","length","i","F","s","done","value","e","_e2","f","TypeError","err","normalCompletion","didErr","step","next","_e3","return","arr","len","arr2","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","_isNativeReflectConstruct","result","Super","NewTarget","this","arguments","apply","_CreationDataStorage","_InstanceDataStorage","visibleInstances","batchCache","_InstancesBatch","batchCacheReplacementModeInFrozenMode","instancesBufferSize","mustReturn","renderSelf","hardwareInstancedRendering","_ThinInstanceDataStorage","instancesCount","matrixBuffer","previousMatrixBuffer","matrixBufferSize","matrixData","boundingVectors","worldMatrices","_InternalMeshDataInfo","_areNormalsFrozen","_source","meshMap","_preActivateId","_LODLevels","_useLODScreenCoverage","_effectiveMaterial","_forcedInstanceCount","_overrideRenderingFillMode","Mesh","_AbstractMesh","_super","_this","scene","undefined","parent","source","doNotCloneChildren","clonePhysicsImpostor","_internalMeshDataInfo","delayLoadState","instances","_creationDataStorage","_geometry","_instanceDataStorage","_thinInstanceDataStorage","_shouldGenerateFlatShading","_originalBuilderSideOrientation","DEFAULTSIDE","overrideMaterialSideOrientation","ignoreCameraMaxZ","getScene","_onBeforeDraw","isInstance","world","effectiveMaterial","_uniformBuffer","transferToEffect","bindOnlyWorldMatrix","applyToMesh","useClonedMeshMap","uniqueId","_ranges","ranges","_name","hasOwnProperty","createAnimationRange","to","metadata","clone","_internalMetadata","setEnabled","isEnabled","setPivotMatrix","getPivotMatrix","id","material","directDescendants","getDescendants","index","child","morphTargetManager","getPhysicsEngine","physicsEngine","getPluginVersion","impostor","getImpostorForPhysicsObject","physicsImpostor","physicsBody","_index","particleSystems","system","emitter","skeleton","refreshBoundingInfo","computeWorldMatrix","getEngine","getCaps","instancedArrays","_onMeshReadyObserverAdded","observer","unregisterOnNextCall","isReady","onMeshReadyObservable","notifyObservers","_checkReadinessObserver","_scene","onBeforeRenderObservable","add","remove","onClonedObservable","key","get","set","_sortLODLevels","_internalAbstractMeshDataInfo","_computeBonesUsingShaders","_sourcePositions","setVerticesData","_sourceNormals","_markSubMeshesAsAttributesDirty","_onBeforeRenderObservable","_onBeforeBindObservable","_onAfterRenderObservable","_onBetweenPassObservable","_onBeforeDrawObservable","callback","_onBeforeDrawObserver","onBeforeDrawObservable","_a","count","fillMode","_unIndexed","instancesData","instancesPreviousData","manualUpdate","previousManualUpdate","forceMatrixUpdates","newParent","options","onNewNodeCreated","instance","getTotalVertices","doNotInstantiate","createInstance","position","scaling","rotationQuaternion","rotation","_step","_iterator","getChildTransformNodes","getClassName","sourceMesh","instantiateHierarchy","newSourcedMesh","fullDetails","ret","_waitingParentId","animations","ib","getIndices","vb","getVerticesData","_step2","_iterator2","_unBindEffect","sortingOrderFactor","sort","a","b","distanceOrScreenCoverage","mesh","_masterMesh","level","push","distance","internalDataInfo","splice","camera","boundingSphere","bSphere","getBoundingInfo","distanceToCamera","mode","minZ","centerWorld","subtract","globalPosition","compareValue","compareSign","screenArea","meshArea","radiusWorld","Math","PI","onLODLevelSelection","_checkDelayState","_preActivate","_updateSubMeshesBoundingInfo","worldMatrixFromCache","kind","copyWhenShared","forceCopy","bypassInstanceData","_b","data","_userInstancedBuffersStorage","vertexBuffers","getFloatData","meshes","getVertexBuffer","isVerticesDataPresent","_delayInfo","indexOf","buffer","isUpdatable","isVertexBufferUpdatable","forEach","kinds","getVerticesDataKinds","getTotalIndices","_c","_d","_e","_f","completeCheck","forceInstanceSupport","subMeshes","engine","hasThinInstances","mat","defaultMaterial","_storeEffectOnSubMeshes","_step3","_iterator3","subMesh","getMaterial","isReadyForSubMesh","_step4","currentRenderPassId","_iterator4","lightSources","light","generators","getShadowGenerators","values","generator","getShadowMap","renderList","renderPassId","_step6","_iterator6","_subMesh","needAlphaBlendingForMesh","_step5","_iterator5","lod","overridenInstanceCount","sceneRenderId","getRenderId","renderId","intermediateDefaultRenderId","defaultRenderId","selfDefaultRenderId","_renderId","previousRenderId","isFrozen","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","edgesShareWithInstances","edgesRenderer","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","getWorldMatrix","applySkeleton","applyMorph","hasBoundingInfo","isLocked","bias","geometry","boundingBias","_refreshBoundingInfo","_getPositionData","force","totalVertices","totalIndices","needToRecreate","_step7","_iterator7","submesh","indexStart","indexCount","verticesStart","verticesCount","releaseSubMeshes","subdivisionSize","offset","synchronizeInstances","updatable","stride","vertexData","removeVerticesData","disposeExistingBuffer","setVerticesBuffer","updateExtends","makeItUnique","makeGeometryUnique","updateVerticesData","positionFunction","computeNormals","positions","indices","normals","oldGeometry","copy","releaseForMesh","setIndices","gpuMemoryOnly","updateIndices","toLeftHanded","effect","allowInstancedRendering","indexToBind","isUsingTextureForTargets","_bind","_getRenderingFillMode","_getLinesIndexBuffer","getIndexBuffer","vertexArrayObjects","getVertexBuffers","drawArraysType","forcedInstanceCount","drawElementsType","_linesIndexCount","func","removeCallback","onAfterRenderObservable","subMeshId","isReplacementMode","previousBatch","isInIntermediateRendering","_isInIntermediateRendering","onlyForInstances","_onlyForInstancesIntermediate","_onlyForInstances","isVisible","currentRenderId","batch","_id","visibleInstanceCount","instanceStorage","currentInstancesBufferSize","instancesBuffer","instancesPreviousBuffer","bufferSize","Float32Array","needsPreviousWorldMatrices","needUpdateBuffer","masterMeshPreviousWorldMatrix","copyToArray","copyFrom","INSTANCEDMESH_SORT_TRANSPARENT","activeCamera","getRenderingMesh","cameraPosition","instanceIndex","instanceMesh","_distanceToCamera","m1","m2","_instanceIndex","matrix","_previousWorldMatrix","dispose","strides","sizes","vertexArrayObject","createVertexBuffer","_invalidateInstanceVertexArrayObject","updateDirectly","_processInstancedBuffers","_activeIndices","addCount","_currentDrawContext","useInstancing","_draw","unbindInstanceAttributes","previousMatrixData","_thinInstanceCreateMatrixBuffer","renderingMesh","onBeforeDraw","_renderWithThinInstances","_renderWithInstances","instanceCount","visibleInstancesForSubMesh","_getInstancesRenderList","enableAlphaMode","effectiveMeshReplacement","_isActiveIntermediate","_isActive","_checkOcclusionQuery","_occlusionDataStorage","forceRenderingWhenOccluded","oldCameraMaxZ","oldCamera","maxZ","updateTransformMatrix","drawWrapper","getMesh","_actAsRegularMesh","instanceDataStorage","_wasPreviouslyReady","getEffect","setAlphaMode","alphaMode","_step8","_drawWrapper","_getDrawWrapper","_iterator8","_beforeRenderingMeshStage","action","sideOrientation","effectiveMesh","backFaceCulling","mainDeterminant","_getWorldMatrixDeterminant","reverse","_preBind","forceDepthWrite","setDepthWrite","bindForSubMesh","bind","separateCullingPass","setState","zOffset","cullBackFaces","stencil","zOffsetUnits","_processRendering","unbind","_step9","_iterator9","_afterRenderingMeshStage","performancePriority","_freeze","_normalizeSkinWeightsAndExtra","_normalizeSkinFourWeights","matricesWeights","numWeights","t","recip","matricesWeightsExtra","skinned","valid","report","numberNotSorted","missingWeights","maxUsedWeights","numberNotNormalized","numInfluences","usedWeightCounts","_a2","lastWeight","usedWeights","d","tolerance","_b2","abs","numBones","bones","matricesIndices","matricesIndicesExtra","numBadBoneIndices","_a3","_b3","load","_queueLoad","_this2","addPendingData","getBinaryData","delayLoadingFile","ArrayBuffer","_delayLoadingFunction","JSON","parse","_syncSubMeshes","removePendingData","offlineProvider","frustumPlanes","materials","multiMaterials","results","transform","submeshes","_resetPointsArrayCache","temp","toArray","normalize","determinant","flipFaces","bakeIndependentlyOfChildren","bakeTransformIntoVertices","resetLocalMatrix","_positions","_generatePointsArray","doNotRecurse","disposeMaterialAndTextures","clear","_step11","_iterator10","abstractMesh","_mesh","_disposeInstanceSpecificData","_disposeThinInstanceSpecificData","url","minHeight","maxHeight","onSuccess","uvOffset","uvScale","_this3","forceUpdate","onload","img","heightMapWidth","width","heightMapHeight","height","context","createCanvas","getContext","drawImage","getImageData","applyDisplacementMapFromBuffer","uvs","normal","uv","u","x","v","y","pos","r","g","gradient","scaleInPlace","kindIndex","vbs","newdata","updatableNormals","vertexBuffer","getData","previousSubmeshes","vertexIndex","getStrideSize","flipNormalGeneration","useRightHandedSystem","p1","p2","p3","p1p2","p3p2","localIndex","z","submeshIndex","previousOne","materialIndex","flipNormals","vertex_data","numberPerEdge","currentIndices","segments","tempIndices","uvPtr","normalsPtr","deltaPosition","deltaNormal","deltaUV","side","positionPtr","_i","j","k","idx","_k","_j","_k2","_j2","currentUVs","currentPositions","currentColors","colors","currentMatrixIndices","currentMatrixWeights","currentMatrixIndicesExtra","currentMatrixWeightsExtra","ptr","facet","matrixIndices","matrixWeights","matrixIndicesExtra","matrixWeightsExtra","pstring","indexPtr","uniquePositions","_j3","_k3","_k4","_k5","_k6","_k7","_k8","_k9","_instancedMeshFactory","successCallback","_this4","vectorPositions","dupes","iteration","realPos","testedPosition","againstPosition","equals","originalSubMeshes","serializationObject","type","tags","asArray","_postMultiplyPivotMatrix","pivotMatrix","localMatrix","infiniteDistance","pickable","isPickable","receiveShadows","billboardMode","visibility","checkCollisions","isBlocker","_serializeAsParent","isUnIndexed","geometryUniqueId","geometryId","subIndex","doNotSerialize","materialUniqueId","materialId","morphTargetManagerId","skeletonId","numBoneInfluencers","_getComponent","getPhysicsImpostor","physicsMass","getParam","physicsFriction","physicsRestitution","serializationInstance","_impostor","actionManager","actions","serialize","serializeAnimationRanges","thinInstances","enablePicking","thinInstanceEnablePicking","_userThinInstanceBuffersStorage","userThinInstance","layerMask","alphaIndex","hasVertexAlpha","overlayAlpha","overlayColor","renderOverlay","applyFog","_morphTargetManager","vertexCount","numInfluencers","morphTarget","getActiveTarget","getPositions","getNormals","tangents","getTangents","getUVs","_index2","_softwareSkinningFrameId","getFrameId","hasNormals","setPositionsForCPUSkinning","setNormalsForCPUSkinning","positionsData","normalsData","matricesIndicesData","matricesWeightsData","inf","needExtras","matricesIndicesExtraData","matricesWeightsExtraData","skeletonMatrices","getTransformMatrices","tempVector3","finalMatrix","tempMatrix","matWeightIdx","weight","floor","addToSelf","reset","_indexInSourceMeshInstanceArray","last","pop","forcePointsCloud","forceWireframe","overrideRenderingFillMode","orientation","FRONTSIDE","physicObject","jsonObject","parsedMesh","rootUrl","_LinesMeshParser","_GroundMeshParser","_GoldbergMeshParser","_waitingParsedUniqueId","setPreTransformMatrix","showBoundingBox","showSubMeshesBoundingBox","useFlatShading","freezeWorldMatrix","_waitingData","parentId","parentInstanceIndex","_waitingParentInstanceIndex","buildBoundingInfo","boundingBoxMinimum","boundingBoxMaximum","_binaryInfo","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","_waitingMaterialId","getMorphTargetManagerById","getLastSkeletonById","animationIndex","parsedAnimation","internalClass","Parse","N","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","isNaN","parseInt","_PhysicsImpostorParser","lodMeshIds","lods","ids","distances","lodDistances","coverages","lodCoverages","parsedInstance","_animationIndex","_parsedAnimation","_internalClass","thinInstanceSetBuffer","minVector","maxVector","boundingBox","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","min","max","meshesOrMinMaxVector","minMaxVector","MinMax","disposeSource","allow32BitsIndices","meshSubclass","subdivideWithSubMeshes","multiMultiMaterials","_MergeMeshesCoroutine","isAsync","_callee","materialArray","materialIndexArray","indiceArray","currentOverrideMaterialSideOrientation","matIndex","_subIndex","_subIndex2","getVertexDataFromMesh","_getVertexDataFromMes","sourceVertexData","sourceTransform","meshVertexDatas","mergeCoroutine","mergeCoroutineStep","applyToCoroutine","applyToCoroutineStep","_iterator11","_step12","newMultiMaterial","_subIndex3","_context","prev","filter","abrupt","isAnInstance","subMaterials","wm","_mergeCoroutine","_applyToCoroutine","stop","BACKSIDE","DOUBLESIDE","NO_CAP","CAP_START","CAP_END","CAP_ALL","NO_FLIP","FLIP_TILE","ROTATE_TILE","FLIP_ROW","ROTATE_ROW","FLIP_N_ROTATE_TILE","FLIP_N_ROTATE_ROW","CENTER","LEFT","RIGHT","TOP","BOTTOM","setMaterialByID","setMaterialById","CreateDisc","Error","CreateBox","CreateSphere","CreateCylinder","CreateTorusKnot","CreateTorus","CreatePlane","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","CreateTube","CreatePolyhedron","CreateIcoSphere","CreateDecal","CreateCapsule","ExtendToGoldberg"],"sourceRoot":""}